"""
Data models for vulnerability chain detection.
"""

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from datetime import datetime
from .constants import RiskLevel, ChainType


@dataclass
class Vulnerability:
    """
    Represents a single vulnerability detected by OWASP ZAP.
    """

    id: str
    name: str
    risk: RiskLevel
    confidence: str
    url: str
    param: Optional[str] = None
    attack: Optional[str] = None
    evidence: Optional[str] = None
    description: Optional[str] = None
    solution: Optional[str] = None
    reference: Optional[str] = None
    cwe_id: Optional[int] = None
    wasc_id: Optional[int] = None
    plugin_id: Optional[str] = None
    alert_ref: Optional[str] = None

    # Additional metadata
    method: Optional[str] = None
    other_info: Optional[str] = None
    tags: Dict[str, Any] = field(default_factory=dict)

    def __hash__(self):
        """Make vulnerability hashable for use in sets and graph nodes."""
        return hash(self.id)

    def __eq__(self, other):
        """Compare vulnerabilities by ID."""
        if not isinstance(other, Vulnerability):
            return False
        return self.id == other.id

    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability to dictionary."""
        return {
            'id': self.id,
            'name': self.name,
            'risk': self.risk.name,
            'confidence': self.confidence,
            'url': self.url,
            'param': self.param,
            'attack': self.attack,
            'evidence': self.evidence,
            'description': self.description,
            'solution': self.solution,
            'reference': self.reference,
            'cwe_id': self.cwe_id,
            'wasc_id': self.wasc_id,
            'plugin_id': self.plugin_id,
            'alert_ref': self.alert_ref,
            'method': self.method,
            'other_info': self.other_info,
            'tags': self.tags
        }

    @classmethod
    def _normalize_vulnerability_name(cls, zap_name: str) -> str:
        """
        Normalize ZAP vulnerability names to standard types for chain detection.

        Args:
            zap_name: Original vulnerability name from ZAP

        Returns:
            Normalized vulnerability type name
        """
        # Mapping of ZAP alert names to standard vulnerability types
        name_mapping = {
            # Security Headers -> can enable XSS
            'Content Security Policy (CSP) Header Not Set': 'Missing Security Headers',
            'Missing Anti-clickjacking Header': 'Missing Security Headers',
            'X-Content-Type-Options Header Missing': 'Missing Security Headers',

            # Information Disclosure
            'Server Leaks Version Information via "Server" HTTP Response Header Field': 'Information Disclosure',
            'Application Error Disclosure': 'Information Disclosure',
            'Directory Browsing': 'Directory Listing',

            # Cookie issues
            'Cookie No HttpOnly Flag': 'Session Fixation',
            'Cookie without SameSite Attribute': 'Session Fixation',
            'Cookie Without Secure Flag': 'Session Fixation',

            # Direct vulnerability types (pass through)
            'SQL Injection': 'SQL Injection',
            'Cross Site Scripting': 'Cross Site Scripting',
            'Cross Site Scripting (Reflected)': 'Cross Site Scripting',
            'Cross Site Scripting (Stored)': 'Cross Site Scripting',
            'Cross Site Scripting (DOM Based)': 'Cross Site Scripting',
            'Path Traversal': 'Path Traversal',
            'Command Injection': 'Command Injection',
            'Remote Code Execution': 'Command Injection',
            'File Upload': 'File Upload Vulnerability',
            'Unrestricted File Upload': 'File Upload Vulnerability',
            'Server Side Request Forgery': 'Server Side Request Forgery',
            'SSRF': 'Server Side Request Forgery',
            'XML External Entity': 'XML External Entity',
            'XXE': 'XML External Entity',
            'Insecure Deserialization': 'Insecure Deserialization',
            'Weak Authentication': 'Weak Authentication',
            'Authentication Bypass': 'Authentication Bypass',
            'Privilege Escalation': 'Privilege Escalation',
            'Insecure Direct Object Reference': 'Insecure Direct Object Reference',
            'IDOR': 'Insecure Direct Object Reference',
        }

        # IMPORTANT: Strip whitespace first!
        zap_name = zap_name.strip()

        # Try exact match first
        if zap_name in name_mapping:
            return name_mapping[zap_name]

        # Try partial matches for common patterns
        zap_lower = zap_name.lower()
        if 'sql injection' in zap_lower or 'sqli' in zap_lower:
            return 'SQL Injection'
        elif 'xss' in zap_lower or 'cross site scripting' in zap_lower or 'cross-site scripting' in zap_lower:
            return 'Cross Site Scripting'
        elif 'path traversal' in zap_lower or 'directory traversal' in zap_lower:
            return 'Path Traversal'
        elif 'command injection' in zap_lower or 'remote code execution' in zap_lower or 'rce' in zap_lower:
            return 'Command Injection'
        elif 'file upload' in zap_lower:
            return 'File Upload Vulnerability'
        elif 'ssrf' in zap_lower or 'server side request forgery' in zap_lower:
            return 'Server Side Request Forgery'
        elif 'xxe' in zap_lower or 'xml external entity' in zap_lower:
            return 'XML External Entity'
        elif 'csrf' in zap_lower or 'cross site request forgery' in zap_lower:
            return 'Anti-CSRF Tokens Check'
        elif 'deserialization' in zap_lower:
            return 'Insecure Deserialization'
        elif 'session' in zap_lower and ('cookie' in zap_lower or 'fixation' in zap_lower):
            return 'Session Fixation'
        elif 'directory' in zap_lower and ('listing' in zap_lower or 'browsing' in zap_lower):
            return 'Directory Listing'
        elif 'information disclosure' in zap_lower or 'information leakage' in zap_lower:
            return 'Information Disclosure'
        elif 'header' in zap_lower and ('missing' in zap_lower or 'not set' in zap_lower):
            return 'Missing Security Headers'
        elif 'cookie' in zap_lower and ('httponly' in zap_lower or 'samesite' in zap_lower or 'secure' in zap_lower or 'флажка' in zap_lower or 'атрибута' in zap_lower):
            return 'Cookie без флажка безопасности'
        elif 'csp' in zap_lower or 'content security policy' in zap_lower:
            return 'Content Security Policy (CSP) Header Not Set'

        # Return original name (stripped) if no mapping found
        return zap_name

    @classmethod
    def from_zap_alert(cls, alert: Dict[str, Any]) -> 'Vulnerability':
        """
        Create a Vulnerability from a ZAP alert dictionary.

        Args:
            alert: Dictionary containing ZAP alert data

        Returns:
            Vulnerability object
        """
        # Handle both 'url' and 'uri' field names (ZAP uses 'uri')
        url = alert.get('url') or alert.get('uri', '')

        # Generate unique ID from alert properties
        vuln_id = f"{alert.get('pluginid', 'unknown')}_{url}_{alert.get('param', '')}"

        # Normalize vulnerability name for chain detection
        original_name = alert.get('name') or alert.get('alert', 'Unknown')
        normalized_name = cls._normalize_vulnerability_name(original_name)

        # Handle risk field - ZAP uses 'riskcode' (0-3) or 'riskdesc' string
        risk_str = alert.get('risk')
        if not risk_str:
            # Map riskcode to risk string
            riskcode = alert.get('riskcode', '0')
            risk_map = {'0': 'Informational', '1': 'Low', '2': 'Medium', '3': 'High'}
            risk_str = risk_map.get(str(riskcode), 'Informational')

        # Handle confidence field - ZAP uses numeric confidence (0-3)
        confidence = alert.get('confidence', 'Medium')
        if isinstance(confidence, (int, str)) and str(confidence).isdigit():
            conf_map = {'0': 'Low', '1': 'Low', '2': 'Medium', '3': 'High'}
            confidence = conf_map.get(str(confidence), 'Medium')

        return cls(
            id=vuln_id,
            name=normalized_name,
            risk=RiskLevel.from_string(risk_str),
            confidence=confidence,
            url=url,
            param=alert.get('param', ''),
            attack=alert.get('attack', ''),
            evidence=alert.get('evidence', ''),
            description=alert.get('description') or alert.get('desc', ''),
            solution=alert.get('solution', ''),
            reference=alert.get('reference', ''),
            cwe_id=int(alert.get('cweid', 0)) if alert.get('cweid') else None,
            wasc_id=int(alert.get('wascid', 0)) if alert.get('wascid') else None,
            plugin_id=alert.get('pluginid'),
            alert_ref=alert.get('alertRef'),
            method=alert.get('method', 'GET'),
            other_info=alert.get('other') or alert.get('otherinfo', '')
        )


@dataclass
class ChainLink:
    """
    Represents a link between two vulnerabilities in a chain.
    """

    source: Vulnerability
    target: Vulnerability
    rule_name: str
    confidence: float
    exploitability: float
    description: str
    conditions_met: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert chain link to dictionary."""
        return {
            'source_id': self.source.id,
            'target_id': self.target.id,
            'rule_name': self.rule_name,
            'confidence': self.confidence,
            'exploitability': self.exploitability,
            'description': self.description,
            'conditions_met': self.conditions_met
        }


@dataclass
class VulnerabilityChain:
    """
    Represents a chain of vulnerabilities that can be exploited together.
    """

    id: str
    vulnerabilities: List[Vulnerability]
    links: List[ChainLink]
    chain_type: ChainType
    risk_score: float
    confidence: float
    impact_description: str
    exploitation_steps: List[str] = field(default_factory=list)
    detected_at: datetime = field(default_factory=datetime.now)

    # Verification fields (added in Phase 3)
    verified: Optional[bool] = None
    verification_confidence: Optional[float] = None
    verification_evidence: Optional[Dict[str, Any]] = None
    verification_timestamp: Optional[datetime] = None
    verified_vulns_count: Optional[int] = None

    def __len__(self):
        """Return the length of the chain."""
        return len(self.vulnerabilities)

    def get_max_risk(self) -> RiskLevel:
        """Get the maximum risk level in the chain."""
        if not self.vulnerabilities:
            return RiskLevel.INFORMATIONAL
        return max(self.vulnerabilities, key=lambda v: v.risk.value).risk

    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability chain to dictionary."""
        result = {
            'id': self.id,
            'chain_type': self.chain_type.value,
            'risk_score': self.risk_score,
            'confidence': self.confidence,
            'length': len(self),
            'max_risk': self.get_max_risk().name,
            'impact_description': self.impact_description,
            'exploitation_steps': self.exploitation_steps,
            'detected_at': self.detected_at.isoformat(),
            'vulnerabilities': [v.to_dict() for v in self.vulnerabilities],
            'links': [link.to_dict() for link in self.links]
        }

        # Add verification fields if present
        if self.verified is not None:
            result['verified'] = self.verified
            result['verification_confidence'] = self.verification_confidence
            result['verification_evidence'] = self.verification_evidence
            result['verified_vulns_count'] = self.verified_vulns_count
            if self.verification_timestamp:
                result['verification_timestamp'] = self.verification_timestamp.isoformat()

        return result

    def get_summary(self) -> str:
        """Get a human-readable summary of the chain."""
        vuln_names = [v.name for v in self.vulnerabilities]
        chain_path = " → ".join(vuln_names)
        return f"[{self.chain_type.value.upper()}] {chain_path} (Risk: {self.risk_score:.2f})"

    def is_verified_exploitable(self) -> bool:
        """
        Check if chain is verified as exploitable.

        Returns True if:
        - Chain has been verified (verified=True)
        - Verification confidence >= 0.8 (80%)
        """
        return (
            self.verified is True and
            self.verification_confidence is not None and
            self.verification_confidence >= 0.8
        )


@dataclass
class ChainDetectionResult:
    """
    Results from vulnerability chain detection analysis.
    """

    chains: List[VulnerabilityChain]
    total_vulnerabilities: int
    total_chains: int
    critical_chains: int
    high_risk_chains: int
    analysis_time: float
    timestamp: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> Dict[str, Any]:
        """Convert detection result to dictionary."""
        return {
            'total_vulnerabilities': self.total_vulnerabilities,
            'total_chains': self.total_chains,
            'critical_chains': self.critical_chains,
            'high_risk_chains': self.high_risk_chains,
            'analysis_time': self.analysis_time,
            'timestamp': self.timestamp.isoformat(),
            'chains': [chain.to_dict() for chain in self.chains]
        }

    def get_chains_by_risk(self, min_risk: float) -> List[VulnerabilityChain]:
        """Get chains with risk score above threshold."""
        return [chain for chain in self.chains if chain.risk_score >= min_risk]

    def get_chains_by_type(self, chain_type: ChainType) -> List[VulnerabilityChain]:
        """Get chains of a specific type."""
        return [chain for chain in self.chains if chain.chain_type == chain_type]
