"""
Data models for vulnerability chain detection.
"""

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from datetime import datetime
from .constants import RiskLevel, ChainType


@dataclass
class Vulnerability:
    """
    Represents a single vulnerability detected by OWASP ZAP.
    """

    id: str
    name: str
    risk: RiskLevel
    confidence: str
    url: str
    param: Optional[str] = None
    attack: Optional[str] = None
    evidence: Optional[str] = None
    description: Optional[str] = None
    solution: Optional[str] = None
    reference: Optional[str] = None
    cwe_id: Optional[int] = None
    wasc_id: Optional[int] = None
    plugin_id: Optional[str] = None
    alert_ref: Optional[str] = None

    # Additional metadata
    method: Optional[str] = None
    other_info: Optional[str] = None
    tags: Dict[str, Any] = field(default_factory=dict)

    def __hash__(self):
        """Make vulnerability hashable for use in sets and graph nodes."""
        return hash(self.id)

    def __eq__(self, other):
        """Compare vulnerabilities by ID."""
        if not isinstance(other, Vulnerability):
            return False
        return self.id == other.id

    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability to dictionary."""
        return {
            'id': self.id,
            'name': self.name,
            'risk': self.risk.name,
            'confidence': self.confidence,
            'url': self.url,
            'param': self.param,
            'attack': self.attack,
            'evidence': self.evidence,
            'description': self.description,
            'solution': self.solution,
            'reference': self.reference,
            'cwe_id': self.cwe_id,
            'wasc_id': self.wasc_id,
            'plugin_id': self.plugin_id,
            'alert_ref': self.alert_ref,
            'method': self.method,
            'other_info': self.other_info,
            'tags': self.tags
        }

    @classmethod
    def from_zap_alert(cls, alert: Dict[str, Any]) -> 'Vulnerability':
        """
        Create a Vulnerability from a ZAP alert dictionary.

        Args:
            alert: Dictionary containing ZAP alert data

        Returns:
            Vulnerability object
        """
        # Generate unique ID from alert properties
        vuln_id = f"{alert.get('pluginid', 'unknown')}_{alert.get('url', '')}_{alert.get('param', '')}"

        return cls(
            id=vuln_id,
            name=alert.get('name', 'Unknown'),
            risk=RiskLevel.from_string(alert.get('risk', 'Informational')),
            confidence=alert.get('confidence', 'Medium'),
            url=alert.get('url', ''),
            param=alert.get('param'),
            attack=alert.get('attack'),
            evidence=alert.get('evidence'),
            description=alert.get('description'),
            solution=alert.get('solution'),
            reference=alert.get('reference'),
            cwe_id=int(alert.get('cweid', 0)) if alert.get('cweid') else None,
            wasc_id=int(alert.get('wascid', 0)) if alert.get('wascid') else None,
            plugin_id=alert.get('pluginid'),
            alert_ref=alert.get('alertRef'),
            method=alert.get('method'),
            other_info=alert.get('other')
        )


@dataclass
class ChainLink:
    """
    Represents a link between two vulnerabilities in a chain.
    """

    source: Vulnerability
    target: Vulnerability
    rule_name: str
    confidence: float
    exploitability: float
    description: str
    conditions_met: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert chain link to dictionary."""
        return {
            'source_id': self.source.id,
            'target_id': self.target.id,
            'rule_name': self.rule_name,
            'confidence': self.confidence,
            'exploitability': self.exploitability,
            'description': self.description,
            'conditions_met': self.conditions_met
        }


@dataclass
class VulnerabilityChain:
    """
    Represents a chain of vulnerabilities that can be exploited together.
    """

    id: str
    vulnerabilities: List[Vulnerability]
    links: List[ChainLink]
    chain_type: ChainType
    risk_score: float
    confidence: float
    impact_description: str
    exploitation_steps: List[str] = field(default_factory=list)
    detected_at: datetime = field(default_factory=datetime.now)

    def __len__(self):
        """Return the length of the chain."""
        return len(self.vulnerabilities)

    def get_max_risk(self) -> RiskLevel:
        """Get the maximum risk level in the chain."""
        if not self.vulnerabilities:
            return RiskLevel.INFORMATIONAL
        return max(v.risk for v in self.vulnerabilities)

    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability chain to dictionary."""
        return {
            'id': self.id,
            'chain_type': self.chain_type.value,
            'risk_score': self.risk_score,
            'confidence': self.confidence,
            'length': len(self),
            'max_risk': self.get_max_risk().name,
            'impact_description': self.impact_description,
            'exploitation_steps': self.exploitation_steps,
            'detected_at': self.detected_at.isoformat(),
            'vulnerabilities': [v.to_dict() for v in self.vulnerabilities],
            'links': [link.to_dict() for link in self.links]
        }

    def get_summary(self) -> str:
        """Get a human-readable summary of the chain."""
        vuln_names = [v.name for v in self.vulnerabilities]
        chain_path = " â†’ ".join(vuln_names)
        return f"[{self.chain_type.value.upper()}] {chain_path} (Risk: {self.risk_score:.2f})"


@dataclass
class ChainDetectionResult:
    """
    Results from vulnerability chain detection analysis.
    """

    chains: List[VulnerabilityChain]
    total_vulnerabilities: int
    total_chains: int
    critical_chains: int
    high_risk_chains: int
    analysis_time: float
    timestamp: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> Dict[str, Any]:
        """Convert detection result to dictionary."""
        return {
            'total_vulnerabilities': self.total_vulnerabilities,
            'total_chains': self.total_chains,
            'critical_chains': self.critical_chains,
            'high_risk_chains': self.high_risk_chains,
            'analysis_time': self.analysis_time,
            'timestamp': self.timestamp.isoformat(),
            'chains': [chain.to_dict() for chain in self.chains]
        }

    def get_chains_by_risk(self, min_risk: float) -> List[VulnerabilityChain]:
        """Get chains with risk score above threshold."""
        return [chain for chain in self.chains if chain.risk_score >= min_risk]

    def get_chains_by_type(self, chain_type: ChainType) -> List[VulnerabilityChain]:
        """Get chains of a specific type."""
        return [chain for chain in self.chains if chain.chain_type == chain_type]
