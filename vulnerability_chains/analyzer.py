"""
VulnerabilityChainAnalyzer - Main interface for vulnerability chain detection.
"""

import logging
from typing import List, Dict, Optional, Any
from pathlib import Path

from .models import Vulnerability, ChainDetectionResult
from .core.vulnerability_graph import VulnerabilityGraph
from .core.chain_detector import ChainDetector
from .core.chain_scoring import ChainScoring
from .rules.chain_rules import ChainRuleEngine
from .utils.zap_parser import ZAPAlertParser
from .visualization.graph_visualizer import GraphVisualizer
from .constants import MAX_CHAIN_LENGTH, MIN_CHAIN_CONFIDENCE

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class VulnerabilityChainAnalyzer:
    """
    Main analyzer for detecting and analyzing vulnerability chains.

    This is the primary interface for using the vulnerability chain detection system.

    Example:
        >>> analyzer = VulnerabilityChainAnalyzer()
        >>> result = analyzer.analyze_zap_report('scan_results.json')
        >>> analyzer.generate_report(result, 'chain_report.html')
    """

    def __init__(
        self,
        rules_file: Optional[str] = None,
        scoring_weights: Optional[Dict[str, float]] = None
    ):
        """
        Initialize the vulnerability chain analyzer.

        Args:
            rules_file: Path to custom chain rules JSON file (uses default if None)
            scoring_weights: Custom weights for risk scoring (uses defaults if None)
        """
        logger.info("Initializing Vulnerability Chain Analyzer")

        # Initialize components
        self.rule_engine = ChainRuleEngine(rules_file)
        self.detector = ChainDetector(self.rule_engine)
        self.scoring = ChainScoring(scoring_weights)
        self.parser = ZAPAlertParser()
        self.visualizer = GraphVisualizer()

        logger.info(
            f"Analyzer initialized with {len(self.rule_engine)} chain rules"
        )

    def analyze_zap_report(
        self,
        report_file: str,
        max_chain_length: int = MAX_CHAIN_LENGTH,
        min_confidence: float = MIN_CHAIN_CONFIDENCE,
        min_risk_filter: Optional[str] = None
    ) -> ChainDetectionResult:
        """
        Analyze OWASP ZAP report for vulnerability chains.

        Args:
            report_file: Path to ZAP JSON report file
            max_chain_length: Maximum chain length to detect
            min_confidence: Minimum confidence threshold for chains
            min_risk_filter: Minimum risk level ('Low', 'Medium', 'High', 'Critical')

        Returns:
            ChainDetectionResult with all detected chains

        Example:
            >>> analyzer = VulnerabilityChainAnalyzer()
            >>> result = analyzer.analyze_zap_report('zap_report.json')
            >>> print(f"Found {result.total_chains} chains")
        """
        logger.info(f"Analyzing ZAP report: {report_file}")

        # Parse ZAP report
        vulnerabilities = self.parser.parse_zap_report(report_file)
        logger.info(f"Parsed {len(vulnerabilities)} vulnerabilities")

        # Filter by risk if specified
        if min_risk_filter:
            from .constants import RiskLevel
            min_risk = RiskLevel[min_risk_filter.upper()]
            vulnerabilities = self.parser.filter_by_risk(vulnerabilities, min_risk)
            logger.info(
                f"Filtered to {len(vulnerabilities)} vulnerabilities "
                f"with risk >= {min_risk_filter}"
            )

        # Detect chains
        result = self.detector.detect_chains(
            vulnerabilities,
            max_length=max_chain_length,
            min_confidence=min_confidence
        )

        # Score chains
        result = self.scoring.score_detection_result(result)

        logger.info(
            f"Analysis complete: {result.total_chains} chains detected "
            f"({result.critical_chains} critical, {result.high_risk_chains} high risk)"
        )

        return result

    def analyze_vulnerabilities(
        self,
        vulnerabilities: List[Vulnerability],
        max_chain_length: int = MAX_CHAIN_LENGTH,
        min_confidence: float = MIN_CHAIN_CONFIDENCE
    ) -> ChainDetectionResult:
        """
        Analyze a list of vulnerabilities for chains.

        Args:
            vulnerabilities: List of Vulnerability objects
            max_chain_length: Maximum chain length to detect
            min_confidence: Minimum confidence threshold for chains

        Returns:
            ChainDetectionResult with all detected chains

        Example:
            >>> vulns = [vuln1, vuln2, vuln3]
            >>> result = analyzer.analyze_vulnerabilities(vulns)
        """
        logger.info(f"Analyzing {len(vulnerabilities)} vulnerabilities")

        # Detect chains
        result = self.detector.detect_chains(
            vulnerabilities,
            max_length=max_chain_length,
            min_confidence=min_confidence
        )

        # Score chains
        result = self.scoring.score_detection_result(result)

        logger.info(f"Analysis complete: {result.total_chains} chains detected")

        return result

    def generate_report(
        self,
        result: ChainDetectionResult,
        output_file: Optional[str] = None,
        format: str = 'html'
    ) -> str:
        """
        Generate report for chain detection results.

        Args:
            result: ChainDetectionResult object
            output_file: Output file path (auto-generated if None)
            format: Report format ('html' or 'json')

        Returns:
            Path to generated report file

        Example:
            >>> result = analyzer.analyze_zap_report('zap_report.json')
            >>> report_path = analyzer.generate_report(result, format='html')
        """
        if format == 'html':
            return self.visualizer.generate_html_report(result, output_file)
        elif format == 'json':
            return self.visualizer.export_to_json(result, output_file)
        else:
            raise ValueError(f"Unsupported format: {format}")

    def get_graph(self) -> Optional[VulnerabilityGraph]:
        """
        Get the vulnerability graph from the last analysis.

        Returns:
            VulnerabilityGraph or None if no analysis has been performed
        """
        return self.detector.graph

    def get_statistics(self, result: ChainDetectionResult) -> Dict[str, Any]:
        """
        Get comprehensive statistics about the analysis.

        Args:
            result: ChainDetectionResult object

        Returns:
            Dictionary with detailed statistics

        Example:
            >>> result = analyzer.analyze_zap_report('zap_report.json')
            >>> stats = analyzer.get_statistics(result)
            >>> print(f"Average risk: {stats['scoring']['average_risk']:.2f}")
        """
        stats = {
            'detection': {
                'total_vulnerabilities': result.total_vulnerabilities,
                'total_chains': result.total_chains,
                'critical_chains': result.critical_chains,
                'high_risk_chains': result.high_risk_chains,
                'analysis_time': result.analysis_time
            },
            'scoring': self.scoring.get_scoring_summary(result.chains),
            'graph': self.detector.graph.get_graph_stats() if self.detector.graph else {},
            'rules': self.rule_engine.get_statistics()
        }

        return stats

    def find_chains_for_vulnerability(
        self,
        vuln_id: str,
        result: ChainDetectionResult
    ) -> List[Any]:
        """
        Find all chains containing a specific vulnerability.

        Args:
            vuln_id: Vulnerability ID
            result: ChainDetectionResult to search

        Returns:
            List of chains containing the vulnerability
        """
        return self.detector.get_chains_by_vulnerability(vuln_id, result.chains)

    def get_top_chains(
        self,
        result: ChainDetectionResult,
        n: int = 10,
        min_risk: Optional[float] = None
    ) -> List[Any]:
        """
        Get top N highest risk chains.

        Args:
            result: ChainDetectionResult object
            n: Number of top chains to return
            min_risk: Minimum risk score threshold

        Returns:
            List of top chains

        Example:
            >>> result = analyzer.analyze_zap_report('zap_report.json')
            >>> top_chains = analyzer.get_top_chains(result, n=5, min_risk=10.0)
        """
        return self.scoring.get_top_chains(result.chains, n, min_risk)

    def export_results(
        self,
        result: ChainDetectionResult,
        output_dir: str,
        formats: List[str] = ['html', 'json']
    ) -> Dict[str, str]:
        """
        Export results in multiple formats.

        Args:
            result: ChainDetectionResult object
            output_dir: Output directory
            formats: List of formats to export ('html', 'json')

        Returns:
            Dictionary mapping format to output file path

        Example:
            >>> result = analyzer.analyze_zap_report('zap_report.json')
            >>> files = analyzer.export_results(result, 'output/', ['html', 'json'])
        """
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)

        exported_files = {}

        for fmt in formats:
            if fmt == 'html':
                file_path = self.visualizer.generate_html_report(
                    result,
                    str(output_path / 'chain_report.html')
                )
                exported_files['html'] = file_path
            elif fmt == 'json':
                file_path = self.visualizer.export_to_json(
                    result,
                    str(output_path / 'chain_results.json')
                )
                exported_files['json'] = file_path

        logger.info(f"Exported results to {len(exported_files)} files")
        return exported_files

    def print_summary(self, result: ChainDetectionResult) -> None:
        """
        Print a summary of the analysis results to console.

        Args:
            result: ChainDetectionResult object

        Example:
            >>> result = analyzer.analyze_zap_report('zap_report.json')
            >>> analyzer.print_summary(result)
        """
        print("\n" + "="*70)
        print("ðŸ”— VULNERABILITY CHAIN DETECTION SUMMARY")
        print("="*70)
        print(f"\nðŸ“Š Statistics:")
        print(f"   Total Vulnerabilities: {result.total_vulnerabilities}")
        print(f"   Total Chains Detected: {result.total_chains}")
        print(f"   Critical Chains: {result.critical_chains}")
        print(f"   High Risk Chains: {result.high_risk_chains}")
        print(f"   Analysis Time: {result.analysis_time:.2f}s")

        if result.chains:
            print(f"\nðŸ” Top 5 Chains by Risk:")
            top_chains = self.get_top_chains(result, n=5)
            for i, chain in enumerate(top_chains, 1):
                print(f"\n   {i}. {chain.get_summary()}")
                print(f"      Confidence: {chain.confidence:.0%}")
                print(f"      Max Risk: {chain.get_max_risk().name}")

        print("\n" + "="*70 + "\n")

    def __repr__(self) -> str:
        """String representation of the analyzer."""
        return (
            f"VulnerabilityChainAnalyzer("
            f"rules={len(self.rule_engine)}, "
            f"graph={'active' if self.detector.graph else 'inactive'})"
        )


# Convenience function for quick analysis
def analyze_zap_scan(
    report_file: str,
    output_file: Optional[str] = None,
    generate_html: bool = True
) -> ChainDetectionResult:
    """
    Convenience function for quick ZAP scan analysis.

    Args:
        report_file: Path to ZAP JSON report
        output_file: Output HTML report file (auto-generated if None)
        generate_html: Whether to generate HTML report

    Returns:
        ChainDetectionResult

    Example:
        >>> from vulnerability_chains import analyze_zap_scan
        >>> result = analyze_zap_scan('zap_report.json')
        >>> print(f"Found {result.total_chains} vulnerability chains")
    """
    analyzer = VulnerabilityChainAnalyzer()
    result = analyzer.analyze_zap_report(report_file)

    if generate_html:
        analyzer.generate_report(result, output_file)

    analyzer.print_summary(result)

    return result
