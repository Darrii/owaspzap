"""
FastAPI Web Application for Vulnerability Chain Detection.
"""

import os
import json
import shutil
from pathlib import Path
from typing import Optional, List
from datetime import datetime

from fastapi import FastAPI, File, UploadFile, HTTPException, Request
from fastapi.responses import HTMLResponse, JSONResponse, FileResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.middleware.cors import CORSMiddleware
import uvicorn

# Import vulnerability chain detection components
import sys
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from vulnerability_chains import VulnerabilityChainAnalyzer
from vulnerability_chains.models import ChainDetectionResult


# Initialize FastAPI app
app = FastAPI(
    title="Vulnerability Chain Detection",
    description="Graph-based analysis of compound exploits in web applications",
    version="1.0.0"
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Setup directories
BASE_DIR = Path(__file__).parent
UPLOAD_DIR = BASE_DIR / "uploads"
REPORTS_DIR = BASE_DIR.parent.parent / "reports" / "chains"
STATIC_DIR = BASE_DIR / "static"
TEMPLATES_DIR = BASE_DIR / "templates"

# Create directories if they don't exist
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)
REPORTS_DIR.mkdir(parents=True, exist_ok=True)

# Mount static files
app.mount("/static", StaticFiles(directory=str(STATIC_DIR)), name="static")

# Setup templates
templates = Jinja2Templates(directory=str(TEMPLATES_DIR))

# Global analyzer instance
analyzer = VulnerabilityChainAnalyzer()

# Store analysis results in memory (for demo purposes)
analysis_cache = {}


@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    """Home page with upload form and dashboard."""
    return templates.TemplateResponse("index.html", {"request": request})


@app.get("/api/health")
async def health_check():
    """Health check endpoint."""
    return {
        "status": "healthy",
        "service": "Vulnerability Chain Detection",
        "version": "1.0.0",
        "timestamp": datetime.now().isoformat()
    }


@app.post("/api/upload")
async def upload_zap_report(file: UploadFile = File(...)):
    """
    Upload ZAP report for analysis.

    Args:
        file: ZAP JSON report file

    Returns:
        Analysis ID and basic info
    """
    # Validate file type
    if not file.filename.endswith('.json'):
        raise HTTPException(status_code=400, detail="Only JSON files are accepted")

    # Generate unique ID
    analysis_id = datetime.now().strftime("%Y%m%d_%H%M%S_%f")

    # Save uploaded file
    file_path = UPLOAD_DIR / f"{analysis_id}_{file.filename}"

    try:
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to save file: {str(e)}")

    return {
        "analysis_id": analysis_id,
        "filename": file.filename,
        "file_path": str(file_path),
        "status": "uploaded",
        "message": "File uploaded successfully. Use /api/analyze/{analysis_id} to start analysis."
    }


@app.post("/api/analyze/{analysis_id}")
async def analyze_report(
    analysis_id: str,
    max_chain_length: int = 5,
    min_confidence: float = 0.6,
    min_risk_filter: Optional[str] = None
):
    """
    Analyze uploaded ZAP report.

    Args:
        analysis_id: Analysis ID from upload
        max_chain_length: Maximum chain length to detect
        min_confidence: Minimum confidence threshold
        min_risk_filter: Minimum risk level filter

    Returns:
        Analysis results
    """
    # Find uploaded file
    uploaded_files = list(UPLOAD_DIR.glob(f"{analysis_id}_*"))

    if not uploaded_files:
        raise HTTPException(status_code=404, detail="Analysis ID not found")

    file_path = uploaded_files[0]

    try:
        # Perform analysis
        result = analyzer.analyze_zap_report(
            report_file=str(file_path),
            max_chain_length=max_chain_length,
            min_confidence=min_confidence,
            min_risk_filter=min_risk_filter
        )

        # Generate HTML report
        html_report = analyzer.generate_report(
            result,
            output_file=str(REPORTS_DIR / f"chain_report_{analysis_id}.html")
        )

        # Generate JSON report
        json_report = analyzer.generate_report(
            result,
            output_file=str(REPORTS_DIR / f"chain_results_{analysis_id}.json"),
            format='json'
        )

        # Cache result
        analysis_cache[analysis_id] = {
            'result': result,
            'html_report': html_report,
            'json_report': json_report,
            'timestamp': datetime.now().isoformat()
        }

        # Get statistics
        stats = analyzer.get_statistics(result)

        return {
            "analysis_id": analysis_id,
            "status": "completed",
            "statistics": {
                "total_vulnerabilities": result.total_vulnerabilities,
                "total_chains": result.total_chains,
                "critical_chains": result.critical_chains,
                "high_risk_chains": result.high_risk_chains,
                "analysis_time": result.analysis_time
            },
            "reports": {
                "html": f"/api/report/{analysis_id}/html",
                "json": f"/api/report/{analysis_id}/json",
                "download_html": f"/api/download/{analysis_id}/html",
                "download_json": f"/api/download/{analysis_id}/json"
            },
            "chains_summary": [
                {
                    "id": chain.id,
                    "type": chain.chain_type.value,
                    "risk_score": chain.risk_score,
                    "length": len(chain),
                    "confidence": chain.confidence,
                    "summary": chain.get_summary()
                }
                for chain in result.chains[:10]  # Top 10 chains
            ]
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Analysis failed: {str(e)}")


@app.get("/api/results/{analysis_id}")
async def get_results(analysis_id: str):
    """Get analysis results by ID."""
    if analysis_id not in analysis_cache:
        raise HTTPException(status_code=404, detail="Analysis results not found")

    cached = analysis_cache[analysis_id]
    result = cached['result']

    return {
        "analysis_id": analysis_id,
        "timestamp": cached['timestamp'],
        "statistics": {
            "total_vulnerabilities": result.total_vulnerabilities,
            "total_chains": result.total_chains,
            "critical_chains": result.critical_chains,
            "high_risk_chains": result.high_risk_chains,
            "analysis_time": result.analysis_time
        },
        "chains": [chain.to_dict() for chain in result.chains]
    }


@app.get("/api/report/{analysis_id}/html", response_class=HTMLResponse)
async def view_html_report(analysis_id: str):
    """View HTML report in browser."""
    report_file = REPORTS_DIR / f"chain_report_{analysis_id}.html"

    if not report_file.exists():
        raise HTTPException(status_code=404, detail="Report not found")

    with open(report_file, 'r', encoding='utf-8') as f:
        return f.read()


@app.get("/api/report/{analysis_id}/json")
async def view_json_report(analysis_id: str):
    """View JSON report."""
    report_file = REPORTS_DIR / f"chain_results_{analysis_id}.json"

    if not report_file.exists():
        raise HTTPException(status_code=404, detail="Report not found")

    with open(report_file, 'r', encoding='utf-8') as f:
        return json.load(f)


@app.get("/api/download/{analysis_id}/html")
async def download_html_report(analysis_id: str):
    """Download HTML report."""
    report_file = REPORTS_DIR / f"chain_report_{analysis_id}.html"

    if not report_file.exists():
        raise HTTPException(status_code=404, detail="Report not found")

    return FileResponse(
        path=str(report_file),
        filename=f"chain_report_{analysis_id}.html",
        media_type="text/html"
    )


@app.get("/api/download/{analysis_id}/json")
async def download_json_report(analysis_id: str):
    """Download JSON report."""
    report_file = REPORTS_DIR / f"chain_results_{analysis_id}.json"

    if not report_file.exists():
        raise HTTPException(status_code=404, detail="Report not found")

    return FileResponse(
        path=str(report_file),
        filename=f"chain_results_{analysis_id}.json",
        media_type="application/json"
    )


@app.get("/api/analyses")
async def list_analyses():
    """List all available analyses."""
    analyses = []

    for analysis_id, cached in analysis_cache.items():
        result = cached['result']
        analyses.append({
            "analysis_id": analysis_id,
            "timestamp": cached['timestamp'],
            "total_chains": result.total_chains,
            "critical_chains": result.critical_chains,
            "high_risk_chains": result.high_risk_chains
        })

    return {
        "total": len(analyses),
        "analyses": sorted(analyses, key=lambda x: x['timestamp'], reverse=True)
    }


@app.delete("/api/analysis/{analysis_id}")
async def delete_analysis(analysis_id: str):
    """Delete analysis and associated files."""
    # Remove from cache
    if analysis_id in analysis_cache:
        del analysis_cache[analysis_id]

    # Delete files
    files_deleted = 0

    # Delete uploaded file
    for file in UPLOAD_DIR.glob(f"{analysis_id}_*"):
        file.unlink()
        files_deleted += 1

    # Delete reports
    for file in REPORTS_DIR.glob(f"*{analysis_id}*"):
        file.unlink()
        files_deleted += 1

    return {
        "status": "deleted",
        "analysis_id": analysis_id,
        "files_deleted": files_deleted
    }


@app.get("/api/rules")
async def get_chain_rules():
    """Get all chain rules."""
    return {
        "total_rules": len(analyzer.rule_engine),
        "statistics": analyzer.rule_engine.get_statistics(),
        "rules": [
            {
                "rule_id": rule.rule_id,
                "name": rule.name,
                "source_type": rule.source_type,
                "target_type": rule.target_type,
                "chain_type": rule.chain_type.value,
                "exploitability": rule.exploitability,
                "impact_multiplier": rule.impact_multiplier,
                "description": rule.description
            }
            for rule in analyzer.rule_engine.rules
        ]
    }


# Run server
def start_server(host: str = "0.0.0.0", port: int = 8000):
    """Start the web server."""
    print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                              â•‘
â•‘   ğŸ”— Vulnerability Chain Detection Web Interface            â•‘
â•‘                                                              â•‘
â•‘   Server running at: http://{host}:{port}                   â•‘
â•‘                                                              â•‘
â•‘   API Documentation: http://{host}:{port}/docs              â•‘
â•‘   Interactive API: http://{host}:{port}/redoc               â•‘
â•‘                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """)

    uvicorn.run(app, host=host, port=port)


if __name__ == "__main__":
    start_server()
