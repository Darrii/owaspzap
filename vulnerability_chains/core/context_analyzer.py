"""
ContextAnalyzer - Groups related vulnerabilities into clusters for finding implicit connections.
"""

from typing import List, Dict, Set, Tuple, TYPE_CHECKING
from collections import defaultdict
from dataclasses import dataclass
import re
from urllib.parse import urlparse

if TYPE_CHECKING:
    from ..models import Vulnerability

import logging

logger = logging.getLogger(__name__)


@dataclass
class VulnerabilityCluster:
    """Cluster of related vulnerabilities"""
    cluster_id: str
    vulnerabilities: List['Vulnerability']
    cluster_type: str  # "endpoint", "parameter", "cookie", "domain_section"
    shared_context: Dict  # Shared context (URL, parameters, etc.)
    internal_links: List[Tuple[str, str, float]]  # (vuln_id_1, vuln_id_2, strength)


class ContextAnalyzer:
    """
    Analyzes vulnerability context to find implicit connections.
    Groups vulnerabilities by common characteristics.
    """

    def __init__(self):
        self.clusters: List[VulnerabilityCluster] = []

    def analyze(self, vulnerabilities: List['Vulnerability']) -> List[VulnerabilityCluster]:
        """Main analysis method"""
        self.clusters = []

        logger.info(f"Analyzing context for {len(vulnerabilities)} vulnerabilities")

        # 1. Cluster by endpoints
        endpoint_clusters = self._cluster_by_endpoint(vulnerabilities)
        self.clusters.extend(endpoint_clusters)
        logger.debug(f"Found {len(endpoint_clusters)} endpoint clusters")

        # 2. Cluster by parameters
        param_clusters = self._cluster_by_parameter(vulnerabilities)
        self.clusters.extend(param_clusters)
        logger.debug(f"Found {len(param_clusters)} parameter clusters")

        # 3. Cluster cookie-related issues
        cookie_clusters = self._cluster_cookie_issues(vulnerabilities)
        self.clusters.extend(cookie_clusters)
        logger.debug(f"Found {len(cookie_clusters)} cookie clusters")

        # 4. Cluster by site sections
        section_clusters = self._cluster_by_site_section(vulnerabilities)
        self.clusters.extend(section_clusters)
        logger.debug(f"Found {len(section_clusters)} section clusters")

        # 5. Cluster by attack surface
        attack_clusters = self._cluster_by_attack_surface(vulnerabilities)
        self.clusters.extend(attack_clusters)
        logger.debug(f"Found {len(attack_clusters)} attack surface clusters")

        logger.info(f"Total {len(self.clusters)} clusters created")
        return self.clusters

    def _cluster_by_endpoint(self, vulns: List['Vulnerability']) -> List[VulnerabilityCluster]:
        """Groups vulnerabilities on the same endpoint"""
        endpoint_map = defaultdict(list)

        for vuln in vulns:
            if vuln.url:
                parsed = urlparse(vuln.url)
                # Remove query string for grouping
                endpoint = f"{parsed.netloc}{parsed.path}"
                endpoint_map[endpoint].append(vuln)

        clusters = []
        for endpoint, vuln_list in endpoint_map.items():
            if len(vuln_list) >= 2:  # Minimum 2 vulnerabilities for cluster
                # Create internal links between all vulnerabilities in cluster
                internal_links = []
                for i, v1 in enumerate(vuln_list):
                    for v2 in vuln_list[i+1:]:
                        # Link strength depends on vulnerability types
                        strength = self._calculate_endpoint_link_strength(v1, v2)
                        if strength > 0.3:
                            internal_links.append((v1.id, v2.id, strength))

                clusters.append(VulnerabilityCluster(
                    cluster_id=f"endpoint_{abs(hash(endpoint)) % 10000}",
                    vulnerabilities=vuln_list,
                    cluster_type="endpoint",
                    shared_context={"endpoint": endpoint},
                    internal_links=internal_links
                ))

        return clusters

    def _cluster_by_parameter(self, vulns: List['Vulnerability']) -> List[VulnerabilityCluster]:
        """Groups vulnerabilities with same/similar parameters"""
        param_map = defaultdict(list)

        # Normalize parameter names
        param_patterns = {
            r'user_?id|userid|uid': 'user_id',
            r'session_?id|sid|sessid': 'session_id',
            r'auth_?token|token|jwt': 'auth_token',
            r'id|item_?id|obj_?id': 'generic_id',
            r'name|username|user_?name': 'username',
            r'pass|password|pwd': 'password',
            r'email|e-?mail': 'email',
            r'redirect|return|next|url|goto': 'redirect_url',
            r'file|filename|path|filepath': 'file_path',
            r'cmd|command|exec': 'command',
            r'query|search|q': 'search_query',
        }

        for vuln in vulns:
            if vuln.param:
                normalized = vuln.param.lower()
                matched = False
                for pattern, category in param_patterns.items():
                    if re.match(pattern, normalized, re.I):
                        param_map[category].append(vuln)
                        matched = True
                        break
                if not matched:
                    param_map[normalized].append(vuln)

        clusters = []
        for param_category, vuln_list in param_map.items():
            if len(vuln_list) >= 2:
                internal_links = []
                for i, v1 in enumerate(vuln_list):
                    for v2 in vuln_list[i+1:]:
                        strength = self._calculate_param_link_strength(v1, v2, param_category)
                        if strength > 0.3:
                            internal_links.append((v1.id, v2.id, strength))

                clusters.append(VulnerabilityCluster(
                    cluster_id=f"param_{param_category}_{abs(hash(param_category)) % 10000}",
                    vulnerabilities=vuln_list,
                    cluster_type="parameter",
                    shared_context={"parameter_category": param_category},
                    internal_links=internal_links
                ))

        return clusters

    def _cluster_cookie_issues(self, vulns: List['Vulnerability']) -> List[VulnerabilityCluster]:
        """Groups all cookie-related problems"""
        cookie_keywords = ['cookie', 'session', 'httponly', 'secure', 'samesite']

        cookie_vulns = [
            v for v in vulns
            if any(kw in v.name.lower() for kw in cookie_keywords)
        ]

        if len(cookie_vulns) < 2:
            return []

        # Group by domain
        domain_map = defaultdict(list)
        for vuln in cookie_vulns:
            if vuln.url:
                domain = urlparse(vuln.url).netloc
                domain_map[domain].append(vuln)

        clusters = []
        for domain, vuln_list in domain_map.items():
            if len(vuln_list) >= 2:
                # All cookie issues on same domain are strongly connected
                internal_links = []
                for i, v1 in enumerate(vuln_list):
                    for v2 in vuln_list[i+1:]:
                        # Cookie issues are always strongly connected
                        strength = 0.8
                        internal_links.append((v1.id, v2.id, strength))

                clusters.append(VulnerabilityCluster(
                    cluster_id=f"cookie_{abs(hash(domain)) % 10000}",
                    vulnerabilities=vuln_list,
                    cluster_type="cookie",
                    shared_context={"domain": domain, "issue_count": len(vuln_list)},
                    internal_links=internal_links
                ))

        return clusters

    def _cluster_by_site_section(self, vulns: List['Vulnerability']) -> List[VulnerabilityCluster]:
        """Groups by site sections (/admin, /api, /user, etc.)"""
        section_map = defaultdict(list)

        section_patterns = [
            (r'/admin', 'admin'),
            (r'/api', 'api'),
            (r'/user', 'user'),
            (r'/account', 'account'),
            (r'/auth', 'auth'),
            (r'/login', 'auth'),
            (r'/dashboard', 'admin'),
            (r'/internal', 'internal'),
            (r'/public', 'public'),
            (r'/static', 'static'),
            (r'/upload', 'upload'),
            (r'/download', 'download'),
        ]

        for vuln in vulns:
            if vuln.url:
                path = urlparse(vuln.url).path.lower()
                for pattern, section in section_patterns:
                    if re.search(pattern, path):
                        section_map[section].append(vuln)
                        break

        clusters = []
        for section, vuln_list in section_map.items():
            if len(vuln_list) >= 2:
                internal_links = []
                for i, v1 in enumerate(vuln_list):
                    for v2 in vuln_list[i+1:]:
                        strength = self._calculate_section_link_strength(v1, v2, section)
                        if strength > 0.3:
                            internal_links.append((v1.id, v2.id, strength))

                clusters.append(VulnerabilityCluster(
                    cluster_id=f"section_{section}_{abs(hash(section)) % 10000}",
                    vulnerabilities=vuln_list,
                    cluster_type="domain_section",
                    shared_context={"section": section},
                    internal_links=internal_links
                ))

        return clusters

    def _cluster_by_attack_surface(self, vulns: List['Vulnerability']) -> List[VulnerabilityCluster]:
        """Groups by attack surface"""
        surface_map = defaultdict(list)

        # Define attack surface by vulnerability type
        surface_keywords = {
            'client_side': ['xss', 'csrf', 'clickjack', 'dom', 'redirect', 'javascript'],
            'server_side': ['injection', 'sqli', 'command', 'rce', 'ssrf', 'xxe'],
            'authentication': ['session', 'auth', 'login', 'password', 'credential', 'token'],
            'configuration': ['header', 'cookie', 'csp', 'cors', 'tls', 'ssl', 'certificate'],
            'information': ['disclosure', 'directory', 'listing', 'version', 'error', 'debug'],
        }

        for vuln in vulns:
            name_lower = vuln.name.lower()
            for surface, keywords in surface_keywords.items():
                if any(kw in name_lower for kw in keywords):
                    surface_map[surface].append(vuln)
                    break

        clusters = []
        for surface, vuln_list in surface_map.items():
            if len(vuln_list) >= 2:
                internal_links = []
                for i, v1 in enumerate(vuln_list):
                    for v2 in vuln_list[i+1:]:
                        strength = 0.5  # Base connection by attack surface
                        internal_links.append((v1.id, v2.id, strength))

                clusters.append(VulnerabilityCluster(
                    cluster_id=f"surface_{surface}_{abs(hash(surface)) % 10000}",
                    vulnerabilities=vuln_list,
                    cluster_type="attack_surface",
                    shared_context={"attack_surface": surface},
                    internal_links=internal_links
                ))

        return clusters

    # Helper methods for calculating link strengths
    def _calculate_endpoint_link_strength(self, v1: 'Vulnerability', v2: 'Vulnerability') -> float:
        """Link strength between vulnerabilities on same endpoint"""
        strength = 0.5  # Base strength

        # Increase if different types (complementary)
        if v1.name != v2.name:
            strength += 0.2

        # Increase if one is high risk
        if int(v1.risk.value) >= 2 or int(v2.risk.value) >= 2:
            strength += 0.2

        return min(strength, 1.0)

    def _calculate_param_link_strength(
        self,
        v1: 'Vulnerability',
        v2: 'Vulnerability',
        param_category: str
    ) -> float:
        """Link strength between vulnerabilities with common parameter"""
        strength = 0.4

        # Critical parameters strengthen the link
        critical_params = ['user_id', 'session_id', 'auth_token', 'password', 'command']
        if param_category in critical_params:
            strength += 0.3

        # Same endpoint strengthens even more
        if v1.url and v2.url:
            if urlparse(v1.url).path == urlparse(v2.url).path:
                strength += 0.2

        return min(strength, 1.0)

    def _calculate_section_link_strength(
        self,
        v1: 'Vulnerability',
        v2: 'Vulnerability',
        section: str
    ) -> float:
        """Link strength between vulnerabilities in same section"""
        strength = 0.4

        # Admin and auth sections are more critical
        if section in ['admin', 'auth', 'internal']:
            strength += 0.3

        return min(strength, 1.0)

    def __repr__(self) -> str:
        return f"ContextAnalyzer({len(self.clusters)} clusters)"
