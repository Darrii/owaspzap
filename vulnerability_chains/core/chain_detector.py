"""
ChainDetector - Algorithm for finding vulnerability chains in the graph.
"""

import logging
import time
from typing import List, Dict, Set, Optional, Tuple
from datetime import datetime
from collections import defaultdict

from ..models import Vulnerability, VulnerabilityChain, ChainLink, ChainDetectionResult
from ..constants import (
    ChainType, MAX_CHAIN_LENGTH, MIN_CHAIN_CONFIDENCE,
    MAX_CHAINS_TO_DETECT, MAX_PATHS_PER_SOURCE
)
from .vulnerability_graph import VulnerabilityGraph
from ..rules.chain_rules import ChainRuleEngine
from ..verification.reachability_checker import ReachabilityChecker

logger = logging.getLogger(__name__)


class ChainDetector:
    """
    Detector for finding vulnerability exploitation chains using graph analysis.
    """

    def __init__(self, rule_engine: Optional[ChainRuleEngine] = None,
                 enable_verification: bool = False,
                 enable_reachability: bool = True,
                 reachability_threshold: float = 0.35):
        """
        Initialize the chain detector.

        Args:
            rule_engine: ChainRuleEngine instance (creates default if None)
            enable_verification: Enable automatic chain verification (Phase 3)
            enable_reachability: Enable URL/parameter reachability filter (Comment 3 fix)
            reachability_threshold: Minimum reachability score to keep a chain edge
        """
        self.rule_engine = rule_engine or ChainRuleEngine()
        self.graph: Optional[VulnerabilityGraph] = None
        self.enable_verification = enable_verification
        self.verifier = None
        self.reachability_checker = (
            ReachabilityChecker(threshold=reachability_threshold)
            if enable_reachability else None
        )

        if enable_verification:
            try:
                from ..verification.chain_verifier import ChainVerifier
                self.verifier = ChainVerifier()
                logger.info("Automatic verification enabled")
            except ImportError as e:
                logger.warning(f"Could not import ChainVerifier: {e}")
                self.enable_verification = False

    def build_graph(self, vulnerabilities: List[Vulnerability]) -> VulnerabilityGraph:
        """
        Build vulnerability graph with automatic link creation based on rules.

        Args:
            vulnerabilities: List of vulnerabilities to analyze

        Returns:
            Constructed VulnerabilityGraph
        """
        logger.info(f"Building vulnerability graph from {len(vulnerabilities)} vulnerabilities")
        start_time = time.time()

        self.graph = VulnerabilityGraph()

        # Add all vulnerabilities to graph
        for vuln in vulnerabilities:
            self.graph.add_vulnerability(vuln)

        # Create links between vulnerabilities based on rules
        links_created = 0
        links_filtered_reachability = 0
        for i, source in enumerate(vulnerabilities):
            for target in vulnerabilities[i+1:]:
                # Try to create links in both directions
                # Source -> Target
                links = self.rule_engine.create_links(source, target)
                for link in links:
                    if self._is_reachable(link):
                        self.graph.add_link(link)
                        links_created += 1
                    else:
                        links_filtered_reachability += 1

                # Target -> Source (reverse direction)
                links = self.rule_engine.create_links(target, source)
                for link in links:
                    if self._is_reachable(link):
                        self.graph.add_link(link)
                        links_created += 1
                    else:
                        links_filtered_reachability += 1

        if links_filtered_reachability > 0:
            logger.info(
                "Reachability filter removed %d edges (kept %d)",
                links_filtered_reachability, links_created
            )

        elapsed = time.time() - start_time
        logger.info(f"Graph built in {elapsed:.2f}s: {len(self.graph)} nodes, {links_created} edges")

        return self.graph

    def detect_chains(
        self,
        vulnerabilities: List[Vulnerability],
        max_length: int = MAX_CHAIN_LENGTH,
        min_confidence: float = MIN_CHAIN_CONFIDENCE,
        verify: bool = False,
        target_url: Optional[str] = None,
        credentials: Optional[Dict[str, str]] = None,
        scan_alerts: Optional[List[Dict]] = None
    ) -> ChainDetectionResult:
        """
        Detect all vulnerability chains in the given set of vulnerabilities.

        Args:
            vulnerabilities: List of vulnerabilities to analyze
            max_length: Maximum chain length to consider
            min_confidence: Minimum confidence threshold for chains
            verify: Enable automatic verification (requires enable_verification=True)
            target_url: Target URL for verification
            credentials: Authentication credentials for verification
            scan_alerts: Raw scan results for exact payload extraction

        Returns:
            ChainDetectionResult containing all detected chains
        """
        logger.info(f"Starting chain detection on {len(vulnerabilities)} vulnerabilities")
        start_time = time.time()

        # Build the graph
        self.build_graph(vulnerabilities)

        # Find all chains
        all_chains = self._find_all_chains(max_length, min_confidence)

        # Remove duplicate and subchains
        unique_chains = self._remove_duplicates_and_subchains(all_chains)

        # Automatic verification (Phase 3)
        if verify and self.enable_verification and self.verifier and target_url:
            logger.info(f"Starting automatic verification of {len(unique_chains)} chains...")
            unique_chains = self._verify_chains(
                unique_chains,
                scan_alerts or [],
                target_url,
                credentials
            )

        # Count critical and high-risk chains
        critical_chains = sum(1 for chain in unique_chains if chain.risk_score >= 15.0)
        high_risk_chains = sum(1 for chain in unique_chains if chain.risk_score >= 10.0)

        elapsed = time.time() - start_time

        result = ChainDetectionResult(
            chains=unique_chains,
            total_vulnerabilities=len(vulnerabilities),
            total_chains=len(unique_chains),
            critical_chains=critical_chains,
            high_risk_chains=high_risk_chains,
            analysis_time=elapsed
        )

        logger.info(f"Detection complete: found {len(unique_chains)} chains in {elapsed:.2f}s")
        return result

    def _verify_chains(
        self,
        chains: List[VulnerabilityChain],
        scan_alerts: List[Dict],
        target_url: str,
        credentials: Optional[Dict[str, str]]
    ) -> List[VulnerabilityChain]:
        """
        Verify all detected chains using automatic verification.

        Args:
            chains: List of chains to verify
            scan_alerts: Raw scan results
            target_url: Target URL
            credentials: Authentication credentials

        Returns:
            List of chains with verification status
        """
        for chain in chains:
            try:
                logger.info(f"Verifying chain {chain.id} (Risk: {chain.risk_score:.2f})...")

                verification_result = self.verifier.verify_chain(
                    chain,
                    scan_alerts,
                    target_url,
                    credentials
                )

                # Add verification metadata to chain
                chain.verified = verification_result.verified
                chain.verification_confidence = verification_result.confidence
                chain.verified_vulns_count = verification_result.verified_vulns
                chain.verification_timestamp = verification_result.timestamp
                chain.verification_evidence = {
                    'test_results': [
                        {
                            'vuln_name': r.vuln_name,
                            'verified': r.verified,
                            'confidence': r.confidence
                        }
                        for r in verification_result.test_results
                    ],
                    'exploitation_path': verification_result.exploitation_path,
                    'failures': verification_result.failures
                }

                logger.info(
                    f"  Chain {chain.id}: {'✓ Verified' if chain.verified else '✗ Not verified'} "
                    f"({verification_result.verified_vulns}/{verification_result.total_vulns} vulns, "
                    f"confidence: {verification_result.confidence:.2f})"
                )

            except Exception as e:
                logger.error(f"Verification failed for chain {chain.id}: {e}")
                chain.verified = False
                chain.verification_confidence = 0.0

        return chains

    def _find_all_chains(self, max_length: int, min_confidence: float) -> List[VulnerabilityChain]:
        """
        Find all vulnerability chains in the graph using A* search.

        Replaces the previous DFS-based approach with A* heuristic search
        (Reviewer Comment 2).  A* expands partial paths in order of
        estimated total exploitability score, so the highest-risk chains are
        found first.  Early stopping after MAX_CHAINS_TO_DETECT guarantees
        polynomial runtime even on large graphs.

        Args:
            max_length: Maximum chain length
            min_confidence: Minimum confidence threshold

        Returns:
            List of detected chains ordered by risk (highest first)
        """
        chains = []
        seen_patterns: Set[Tuple[str, ...]] = set()

        # Get all source nodes (vulnerabilities with no incoming edges)
        source_nodes = self.graph.get_source_nodes()
        if not source_nodes:
            source_nodes = list(self.graph.graph.nodes())

        logger.info(
            "A* chain search from %d source nodes (max %d chains)",
            len(source_nodes), MAX_CHAINS_TO_DETECT
        )

        for source_id in source_nodes:
            source_vuln = self.graph.get_vulnerability(source_id)
            if not source_vuln:
                continue

            if len(chains) >= MAX_CHAINS_TO_DETECT:
                logger.warning("Reached limit of %d chains, stopping A* search", MAX_CHAINS_TO_DETECT)
                break

            # A* returns paths ordered by exploitability (highest first)
            astar_paths = self.graph.find_chains_astar(
                source_id,
                max_length=max_length,
                max_chains=MAX_PATHS_PER_SOURCE
            )

            for path in astar_paths:
                if len(path) < 2:
                    continue

                pattern = self._get_chain_pattern(path)
                if pattern in seen_patterns:
                    continue

                chain = self._create_chain_from_path(path, min_confidence)
                if chain:
                    chains.append(chain)
                    seen_patterns.add(pattern)

                    if len(chains) >= MAX_CHAINS_TO_DETECT:
                        logger.warning("Reached limit of %d unique chains", MAX_CHAINS_TO_DETECT)
                        return chains

        logger.info("A* found %d potential chains", len(chains))
        return chains

    def _get_chain_pattern(self, path: List[str]) -> Tuple[str, ...]:
        """
        Get the pattern of vulnerability types for a chain path.

        Args:
            path: List of vulnerability IDs

        Returns:
            Tuple of vulnerability type names
        """
        types = []
        for vuln_id in path:
            vuln = self.graph.get_vulnerability(vuln_id)
            if vuln:
                types.append(vuln.name)
        return tuple(types)

    def _create_chain_from_path(
        self,
        path: List[str],
        min_confidence: float
    ) -> Optional[VulnerabilityChain]:
        """
        Create a VulnerabilityChain from a path of vulnerability IDs.

        Args:
            path: List of vulnerability IDs forming a path
            min_confidence: Minimum confidence threshold

        Returns:
            VulnerabilityChain or None if invalid
        """
        if len(path) < 2:
            return None

        # Get vulnerabilities and links
        vulnerabilities = []
        links = []

        for vuln_id in path:
            vuln = self.graph.get_vulnerability(vuln_id)
            if not vuln:
                return None
            vulnerabilities.append(vuln)

        # Get links between consecutive vulnerabilities
        for i in range(len(path) - 1):
            source_id = path[i]
            target_id = path[i + 1]

            # Get edge data
            if not self.graph.graph.has_edge(source_id, target_id):
                return None

            edge_data = self.graph.graph[source_id][target_id]
            link = edge_data.get('link')
            if not link:
                return None

            links.append(link)

        # Calculate average confidence
        avg_confidence = sum(link.confidence for link in links) / len(links)

        # Filter by minimum confidence
        if avg_confidence < min_confidence:
            return None

        # Determine chain type (use the most common type from links)
        chain_types = [link.rule_name for link in links]
        # For now, use the first link's chain type
        # In a more sophisticated implementation, we could analyze the overall chain
        chain_type = links[0].description if links else "compound_exploit"

        # Determine overall chain type from rule
        # Try to infer from first rule
        rule_name = links[0].rule_name.lower()
        if 'authentication' in rule_name or 'auth' in rule_name:
            chain_type_enum = ChainType.AUTHENTICATION_BYPASS
        elif 'privilege' in rule_name or 'escalation' in rule_name:
            chain_type_enum = ChainType.PRIVILEGE_ESCALATION
        elif 'rce' in rule_name or 'code execution' in rule_name:
            chain_type_enum = ChainType.REMOTE_CODE_EXECUTION
        elif 'session' in rule_name or 'hijack' in rule_name:
            chain_type_enum = ChainType.SESSION_HIJACKING
        elif 'data' in rule_name or 'exfil' in rule_name:
            chain_type_enum = ChainType.DATA_EXFILTRATION
        elif 'info' in rule_name or 'disclosure' in rule_name:
            chain_type_enum = ChainType.INFORMATION_GATHERING
        else:
            chain_type_enum = ChainType.COMPOUND_EXPLOIT

        # Create impact description
        impact_description = self._generate_impact_description(vulnerabilities, links)

        # Generate exploitation steps
        exploitation_steps = self._generate_exploitation_steps(links)

        # Generate unique chain ID
        chain_id = f"chain_{hash(tuple(path))}"

        # Create the chain (risk_score will be calculated later by ChainScoring)
        chain = VulnerabilityChain(
            id=chain_id,
            vulnerabilities=vulnerabilities,
            links=links,
            chain_type=chain_type_enum,
            risk_score=0.0,  # Will be calculated by scoring system
            confidence=avg_confidence,
            impact_description=impact_description,
            exploitation_steps=exploitation_steps,
            detected_at=datetime.now()
        )

        return chain

    def _generate_impact_description(
        self,
        vulnerabilities: List[Vulnerability],
        links: List[ChainLink]
    ) -> str:
        """
        Generate human-readable impact description for a chain.

        Args:
            vulnerabilities: List of vulnerabilities in chain
            links: List of links in chain

        Returns:
            Impact description string
        """
        vuln_names = [v.name for v in vulnerabilities]
        chain_path = " → ".join(vuln_names)

        max_risk = max(vulnerabilities, key=lambda v: v.risk.value).risk

        impact = (
            f"Exploit chain combining {len(vulnerabilities)} vulnerabilities "
            f"with maximum risk level {max_risk.name}. "
            f"Path: {chain_path}"
        )

        return impact

    def _generate_exploitation_steps(self, links: List[ChainLink]) -> List[str]:
        """
        Generate exploitation steps from chain links.

        Args:
            links: List of links in chain

        Returns:
            List of exploitation step descriptions
        """
        steps = []

        for i, link in enumerate(links, 1):
            # Get exploitation steps from the rule if available
            # For now, use the link description
            step = f"Step {i}: {link.description}"
            steps.append(step)

        return steps

    def _remove_duplicates_and_subchains(
        self,
        chains: List[VulnerabilityChain]
    ) -> List[VulnerabilityChain]:
        """
        Remove duplicate chains and chains that are subchains of others.

        Args:
            chains: List of chains to filter

        Returns:
            Filtered list of unique chains
        """
        if not chains:
            return []

        # Sort chains by length (longest first)
        sorted_chains = sorted(chains, key=lambda c: len(c), reverse=True)

        unique_chains = []
        seen_paths = set()

        for chain in sorted_chains:
            # Create path signature
            path_sig = tuple(v.id for v in chain.vulnerabilities)

            # Check if this path or a superpath has been seen
            is_subchain = False
            for seen_path in seen_paths:
                # Check if current path is a subpath of a seen path
                if self._is_subpath(path_sig, seen_path):
                    is_subchain = True
                    break

            if not is_subchain:
                unique_chains.append(chain)
                seen_paths.add(path_sig)

        logger.info(f"Filtered {len(chains)} chains to {len(unique_chains)} unique chains")
        return unique_chains

    @staticmethod
    def _is_subpath(subpath: Tuple[str, ...], path: Tuple[str, ...]) -> bool:
        """
        Check if subpath is contained within path.

        Args:
            subpath: Potential subpath
            path: Larger path

        Returns:
            True if subpath is found in path
        """
        if len(subpath) > len(path):
            return False

        # Check if subpath appears as consecutive elements in path
        for i in range(len(path) - len(subpath) + 1):
            if path[i:i+len(subpath)] == subpath:
                return True

        return False

    def get_chains_by_vulnerability(
        self,
        vuln_id: str,
        chains: List[VulnerabilityChain]
    ) -> List[VulnerabilityChain]:
        """
        Get all chains containing a specific vulnerability.

        Args:
            vuln_id: Vulnerability ID
            chains: List of chains to search

        Returns:
            List of chains containing the vulnerability
        """
        return [
            chain for chain in chains
            if any(v.id == vuln_id for v in chain.vulnerabilities)
        ]

    def _is_reachable(self, link: ChainLink) -> bool:
        """
        Check whether a chain link passes the reachability filter.

        If reachability checking is disabled (reachability_checker is None),
        all links pass. Otherwise the link is checked using URL/parameter
        proximity analysis.

        Args:
            link: ChainLink to evaluate

        Returns:
            True if link should be kept, False if it should be discarded
        """
        if self.reachability_checker is None:
            return True
        result = self.reachability_checker.check(
            source_url=link.source.url or "",
            target_url=link.target.url or "",
            source_param=link.source.param,
            target_param=link.target.param,
            source_name=link.source.name,
            target_name=link.target.name
        )
        return result.reachable

    def __repr__(self) -> str:
        """String representation of the detector."""
        graph_info = f"graph={len(self.graph)}" if self.graph else "no graph"
        return f"ChainDetector(rules={len(self.rule_engine)}, {graph_info})"
