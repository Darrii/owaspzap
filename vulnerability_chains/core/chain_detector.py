"""
ChainDetector - Algorithm for finding vulnerability chains in the graph.
"""

import logging
import time
from typing import List, Dict, Set, Optional, Tuple
from datetime import datetime
from collections import defaultdict

from ..models import Vulnerability, VulnerabilityChain, ChainLink, ChainDetectionResult
from ..constants import (
    ChainType, MAX_CHAIN_LENGTH, MIN_CHAIN_CONFIDENCE,
    MAX_CHAINS_TO_DETECT, MAX_PATHS_PER_SOURCE
)
from .vulnerability_graph import VulnerabilityGraph
from ..rules.chain_rules import ChainRuleEngine

logger = logging.getLogger(__name__)


class ChainDetector:
    """
    Detector for finding vulnerability exploitation chains using graph analysis.
    """

    def __init__(self, rule_engine: Optional[ChainRuleEngine] = None):
        """
        Initialize the chain detector.

        Args:
            rule_engine: ChainRuleEngine instance (creates default if None)
        """
        self.rule_engine = rule_engine or ChainRuleEngine()
        self.graph: Optional[VulnerabilityGraph] = None

    def build_graph(self, vulnerabilities: List[Vulnerability]) -> VulnerabilityGraph:
        """
        Build vulnerability graph with automatic link creation based on rules.

        Args:
            vulnerabilities: List of vulnerabilities to analyze

        Returns:
            Constructed VulnerabilityGraph
        """
        logger.info(f"Building vulnerability graph from {len(vulnerabilities)} vulnerabilities")
        start_time = time.time()

        self.graph = VulnerabilityGraph()

        # Add all vulnerabilities to graph
        for vuln in vulnerabilities:
            self.graph.add_vulnerability(vuln)

        # Create links between vulnerabilities based on rules
        links_created = 0
        for i, source in enumerate(vulnerabilities):
            for target in vulnerabilities[i+1:]:
                # Try to create links in both directions
                # Source -> Target
                links = self.rule_engine.create_links(source, target)
                for link in links:
                    self.graph.add_link(link)
                    links_created += 1

                # Target -> Source (reverse direction)
                links = self.rule_engine.create_links(target, source)
                for link in links:
                    self.graph.add_link(link)
                    links_created += 1

        elapsed = time.time() - start_time
        logger.info(f"Graph built in {elapsed:.2f}s: {len(self.graph)} nodes, {links_created} edges")

        return self.graph

    def detect_chains(
        self,
        vulnerabilities: List[Vulnerability],
        max_length: int = MAX_CHAIN_LENGTH,
        min_confidence: float = MIN_CHAIN_CONFIDENCE
    ) -> ChainDetectionResult:
        """
        Detect all vulnerability chains in the given set of vulnerabilities.

        Args:
            vulnerabilities: List of vulnerabilities to analyze
            max_length: Maximum chain length to consider
            min_confidence: Minimum confidence threshold for chains

        Returns:
            ChainDetectionResult containing all detected chains
        """
        logger.info(f"Starting chain detection on {len(vulnerabilities)} vulnerabilities")
        start_time = time.time()

        # Build the graph
        self.build_graph(vulnerabilities)

        # Find all chains
        all_chains = self._find_all_chains(max_length, min_confidence)

        # Remove duplicate and subchains
        unique_chains = self._remove_duplicates_and_subchains(all_chains)

        # Count critical and high-risk chains
        critical_chains = sum(1 for chain in unique_chains if chain.risk_score >= 15.0)
        high_risk_chains = sum(1 for chain in unique_chains if chain.risk_score >= 10.0)

        elapsed = time.time() - start_time

        result = ChainDetectionResult(
            chains=unique_chains,
            total_vulnerabilities=len(vulnerabilities),
            total_chains=len(unique_chains),
            critical_chains=critical_chains,
            high_risk_chains=high_risk_chains,
            analysis_time=elapsed
        )

        logger.info(f"Detection complete: found {len(unique_chains)} chains in {elapsed:.2f}s")
        return result

    def _find_all_chains(self, max_length: int, min_confidence: float) -> List[VulnerabilityChain]:
        """
        Find all vulnerability chains in the graph.

        Args:
            max_length: Maximum chain length
            min_confidence: Minimum confidence threshold

        Returns:
            List of detected chains
        """
        chains = []

        # Track unique chain patterns to avoid duplicates
        # Pattern = tuple of vulnerability type names
        seen_patterns = set()

        # Get all source nodes (vulnerabilities with no incoming edges)
        source_nodes = self.graph.get_source_nodes()

        if not source_nodes:
            # If no pure source nodes, use all nodes as potential starting points
            source_nodes = list(self.graph.graph.nodes())

        logger.info(f"Searching for chains from {len(source_nodes)} source nodes (max {MAX_CHAINS_TO_DETECT} chains)")

        # For each source node, find all paths
        for source_id in source_nodes:
            source_vuln = self.graph.get_vulnerability(source_id)
            if not source_vuln:
                continue

            # Early stopping if we reached the limit
            if len(chains) >= MAX_CHAINS_TO_DETECT:
                logger.warning(f"Reached limit of {MAX_CHAINS_TO_DETECT} chains, stopping search")
                break

            # Find all paths from this source (with optimization)
            all_paths = self.graph.find_all_paths_from(
                source_id,
                max_length,
                max_paths=MAX_PATHS_PER_SOURCE
            )

            for target_id, paths in all_paths.items():
                for path in paths:
                    # Skip single-node "chains"
                    if len(path) < 2:
                        continue

                    # Check if we've already seen this pattern of vulnerability types
                    pattern = self._get_chain_pattern(path)
                    if pattern in seen_patterns:
                        continue  # Skip duplicate pattern

                    # Create chain from path
                    chain = self._create_chain_from_path(path, min_confidence)
                    if chain:
                        chains.append(chain)
                        seen_patterns.add(pattern)

                        # Early stopping if we reached the limit
                        if len(chains) >= MAX_CHAINS_TO_DETECT:
                            logger.warning(f"Reached limit of {MAX_CHAINS_TO_DETECT} unique chains, stopping search")
                            return chains

        logger.info(f"Found {len(chains)} potential chains")
        return chains

    def _get_chain_pattern(self, path: List[str]) -> Tuple[str, ...]:
        """
        Get the pattern of vulnerability types for a chain path.

        Args:
            path: List of vulnerability IDs

        Returns:
            Tuple of vulnerability type names
        """
        types = []
        for vuln_id in path:
            vuln = self.graph.get_vulnerability(vuln_id)
            if vuln:
                types.append(vuln.name)
        return tuple(types)

    def _create_chain_from_path(
        self,
        path: List[str],
        min_confidence: float
    ) -> Optional[VulnerabilityChain]:
        """
        Create a VulnerabilityChain from a path of vulnerability IDs.

        Args:
            path: List of vulnerability IDs forming a path
            min_confidence: Minimum confidence threshold

        Returns:
            VulnerabilityChain or None if invalid
        """
        if len(path) < 2:
            return None

        # Get vulnerabilities and links
        vulnerabilities = []
        links = []

        for vuln_id in path:
            vuln = self.graph.get_vulnerability(vuln_id)
            if not vuln:
                return None
            vulnerabilities.append(vuln)

        # Get links between consecutive vulnerabilities
        for i in range(len(path) - 1):
            source_id = path[i]
            target_id = path[i + 1]

            # Get edge data
            if not self.graph.graph.has_edge(source_id, target_id):
                return None

            edge_data = self.graph.graph[source_id][target_id]
            link = edge_data.get('link')
            if not link:
                return None

            links.append(link)

        # Calculate average confidence
        avg_confidence = sum(link.confidence for link in links) / len(links)

        # Filter by minimum confidence
        if avg_confidence < min_confidence:
            return None

        # Determine chain type (use the most common type from links)
        chain_types = [link.rule_name for link in links]
        # For now, use the first link's chain type
        # In a more sophisticated implementation, we could analyze the overall chain
        chain_type = links[0].description if links else "compound_exploit"

        # Determine overall chain type from rule
        # Try to infer from first rule
        rule_name = links[0].rule_name.lower()
        if 'authentication' in rule_name or 'auth' in rule_name:
            chain_type_enum = ChainType.AUTHENTICATION_BYPASS
        elif 'privilege' in rule_name or 'escalation' in rule_name:
            chain_type_enum = ChainType.PRIVILEGE_ESCALATION
        elif 'rce' in rule_name or 'code execution' in rule_name:
            chain_type_enum = ChainType.REMOTE_CODE_EXECUTION
        elif 'session' in rule_name or 'hijack' in rule_name:
            chain_type_enum = ChainType.SESSION_HIJACKING
        elif 'data' in rule_name or 'exfil' in rule_name:
            chain_type_enum = ChainType.DATA_EXFILTRATION
        elif 'info' in rule_name or 'disclosure' in rule_name:
            chain_type_enum = ChainType.INFORMATION_GATHERING
        else:
            chain_type_enum = ChainType.COMPOUND_EXPLOIT

        # Create impact description
        impact_description = self._generate_impact_description(vulnerabilities, links)

        # Generate exploitation steps
        exploitation_steps = self._generate_exploitation_steps(links)

        # Generate unique chain ID
        chain_id = f"chain_{hash(tuple(path))}"

        # Create the chain (risk_score will be calculated later by ChainScoring)
        chain = VulnerabilityChain(
            id=chain_id,
            vulnerabilities=vulnerabilities,
            links=links,
            chain_type=chain_type_enum,
            risk_score=0.0,  # Will be calculated by scoring system
            confidence=avg_confidence,
            impact_description=impact_description,
            exploitation_steps=exploitation_steps,
            detected_at=datetime.now()
        )

        return chain

    def _generate_impact_description(
        self,
        vulnerabilities: List[Vulnerability],
        links: List[ChainLink]
    ) -> str:
        """
        Generate human-readable impact description for a chain.

        Args:
            vulnerabilities: List of vulnerabilities in chain
            links: List of links in chain

        Returns:
            Impact description string
        """
        vuln_names = [v.name for v in vulnerabilities]
        chain_path = " â†’ ".join(vuln_names)

        max_risk = max(vulnerabilities, key=lambda v: v.risk.value).risk

        impact = (
            f"Exploit chain combining {len(vulnerabilities)} vulnerabilities "
            f"with maximum risk level {max_risk.name}. "
            f"Path: {chain_path}"
        )

        return impact

    def _generate_exploitation_steps(self, links: List[ChainLink]) -> List[str]:
        """
        Generate exploitation steps from chain links.

        Args:
            links: List of links in chain

        Returns:
            List of exploitation step descriptions
        """
        steps = []

        for i, link in enumerate(links, 1):
            # Get exploitation steps from the rule if available
            # For now, use the link description
            step = f"Step {i}: {link.description}"
            steps.append(step)

        return steps

    def _remove_duplicates_and_subchains(
        self,
        chains: List[VulnerabilityChain]
    ) -> List[VulnerabilityChain]:
        """
        Remove duplicate chains and chains that are subchains of others.

        Args:
            chains: List of chains to filter

        Returns:
            Filtered list of unique chains
        """
        if not chains:
            return []

        # Sort chains by length (longest first)
        sorted_chains = sorted(chains, key=lambda c: len(c), reverse=True)

        unique_chains = []
        seen_paths = set()

        for chain in sorted_chains:
            # Create path signature
            path_sig = tuple(v.id for v in chain.vulnerabilities)

            # Check if this path or a superpath has been seen
            is_subchain = False
            for seen_path in seen_paths:
                # Check if current path is a subpath of a seen path
                if self._is_subpath(path_sig, seen_path):
                    is_subchain = True
                    break

            if not is_subchain:
                unique_chains.append(chain)
                seen_paths.add(path_sig)

        logger.info(f"Filtered {len(chains)} chains to {len(unique_chains)} unique chains")
        return unique_chains

    @staticmethod
    def _is_subpath(subpath: Tuple[str, ...], path: Tuple[str, ...]) -> bool:
        """
        Check if subpath is contained within path.

        Args:
            subpath: Potential subpath
            path: Larger path

        Returns:
            True if subpath is found in path
        """
        if len(subpath) > len(path):
            return False

        # Check if subpath appears as consecutive elements in path
        for i in range(len(path) - len(subpath) + 1):
            if path[i:i+len(subpath)] == subpath:
                return True

        return False

    def get_chains_by_vulnerability(
        self,
        vuln_id: str,
        chains: List[VulnerabilityChain]
    ) -> List[VulnerabilityChain]:
        """
        Get all chains containing a specific vulnerability.

        Args:
            vuln_id: Vulnerability ID
            chains: List of chains to search

        Returns:
            List of chains containing the vulnerability
        """
        return [
            chain for chain in chains
            if any(v.id == vuln_id for v in chain.vulnerabilities)
        ]

    def __repr__(self) -> str:
        """String representation of the detector."""
        graph_info = f"graph={len(self.graph)}" if self.graph else "no graph"
        return f"ChainDetector(rules={len(self.rule_engine)}, {graph_info})"
