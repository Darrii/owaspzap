"""
VulnerabilityGraph - Graph-based representation of vulnerabilities and their relationships.
"""

import logging
from typing import List, Dict, Set, Tuple, Optional, Any
import networkx as nx
from ..models import Vulnerability, ChainLink
from ..constants import RiskLevel

logger = logging.getLogger(__name__)


class VulnerabilityGraph:
    """
    Graph structure for storing vulnerabilities and their relationships.
    Uses NetworkX directed graph for efficient path finding and analysis.
    """

    def __init__(self):
        """Initialize an empty vulnerability graph."""
        self.graph = nx.DiGraph()
        self._vulnerabilities: Dict[str, Vulnerability] = {}
        self._links: List[ChainLink] = []

    def add_vulnerability(self, vulnerability: Vulnerability) -> None:
        """
        Add a vulnerability as a node in the graph.

        Args:
            vulnerability: Vulnerability object to add
        """
        if vulnerability.id in self._vulnerabilities:
            logger.debug(f"Vulnerability {vulnerability.id} already exists in graph")
            return

        # Store vulnerability object
        self._vulnerabilities[vulnerability.id] = vulnerability

        # Add node to graph with attributes
        self.graph.add_node(
            vulnerability.id,
            vulnerability=vulnerability,
            name=vulnerability.name,
            risk=vulnerability.risk.value,
            risk_name=vulnerability.risk.name,
            confidence=vulnerability.confidence,
            url=vulnerability.url,
            param=vulnerability.param,
            plugin_id=vulnerability.plugin_id,
            cwe_id=vulnerability.cwe_id
        )

        logger.debug(f"Added vulnerability {vulnerability.id}: {vulnerability.name}")

    def add_link(self, link: ChainLink) -> None:
        """
        Add a link (edge) between two vulnerabilities.

        Args:
            link: ChainLink object representing the relationship
        """
        # Ensure both vulnerabilities exist in graph
        if link.source.id not in self._vulnerabilities:
            self.add_vulnerability(link.source)
        if link.target.id not in self._vulnerabilities:
            self.add_vulnerability(link.target)

        # Add edge to graph with link attributes
        self.graph.add_edge(
            link.source.id,
            link.target.id,
            link=link,
            rule_name=link.rule_name,
            confidence=link.confidence,
            exploitability=link.exploitability,
            description=link.description,
            weight=1.0 / link.exploitability  # Lower weight = higher exploitability
        )

        self._links.append(link)
        logger.debug(f"Added link: {link.source.name} â†’ {link.target.name} (rule: {link.rule_name})")

    def get_vulnerability(self, vuln_id: str) -> Optional[Vulnerability]:
        """
        Get vulnerability by ID.

        Args:
            vuln_id: Vulnerability ID

        Returns:
            Vulnerability object or None if not found
        """
        return self._vulnerabilities.get(vuln_id)

    def get_all_vulnerabilities(self) -> List[Vulnerability]:
        """
        Get all vulnerabilities in the graph.

        Returns:
            List of all vulnerabilities
        """
        return list(self._vulnerabilities.values())

    def get_vulnerabilities_by_risk(self, min_risk: RiskLevel) -> List[Vulnerability]:
        """
        Get vulnerabilities with risk level at or above threshold.

        Args:
            min_risk: Minimum risk level

        Returns:
            List of vulnerabilities matching criteria
        """
        return [
            v for v in self._vulnerabilities.values()
            if v.risk.value >= min_risk.value
        ]

    def get_vulnerabilities_by_type(self, vuln_type: str) -> List[Vulnerability]:
        """
        Get vulnerabilities of a specific type.

        Args:
            vuln_type: Vulnerability type name

        Returns:
            List of matching vulnerabilities
        """
        return [
            v for v in self._vulnerabilities.values()
            if v.name == vuln_type
        ]

    def get_outgoing_links(self, vuln_id: str) -> List[ChainLink]:
        """
        Get all outgoing links from a vulnerability.

        Args:
            vuln_id: Vulnerability ID

        Returns:
            List of outgoing chain links
        """
        if vuln_id not in self.graph:
            return []

        links = []
        for successor in self.graph.successors(vuln_id):
            edge_data = self.graph[vuln_id][successor]
            if 'link' in edge_data:
                links.append(edge_data['link'])

        return links

    def get_incoming_links(self, vuln_id: str) -> List[ChainLink]:
        """
        Get all incoming links to a vulnerability.

        Args:
            vuln_id: Vulnerability ID

        Returns:
            List of incoming chain links
        """
        if vuln_id not in self.graph:
            return []

        links = []
        for predecessor in self.graph.predecessors(vuln_id):
            edge_data = self.graph[predecessor][vuln_id]
            if 'link' in edge_data:
                links.append(edge_data['link'])

        return links

    def find_paths(self, source_id: str, target_id: str, max_length: int = 5) -> List[List[str]]:
        """
        Find all simple paths between two vulnerabilities.

        Args:
            source_id: Source vulnerability ID
            target_id: Target vulnerability ID
            max_length: Maximum path length

        Returns:
            List of paths, where each path is a list of vulnerability IDs
        """
        if source_id not in self.graph or target_id not in self.graph:
            return []

        try:
            paths = list(nx.all_simple_paths(
                self.graph,
                source=source_id,
                target=target_id,
                cutoff=max_length
            ))
            return paths
        except nx.NetworkXNoPath:
            return []

    def find_all_paths_from(self, source_id: str, max_length: int = 5) -> Dict[str, List[List[str]]]:
        """
        Find all paths starting from a given vulnerability.

        Args:
            source_id: Source vulnerability ID
            max_length: Maximum path length

        Returns:
            Dictionary mapping target IDs to lists of paths
        """
        if source_id not in self.graph:
            return {}

        all_paths = {}
        for target_id in self.graph.nodes():
            if target_id == source_id:
                continue

            paths = self.find_paths(source_id, target_id, max_length)
            if paths:
                all_paths[target_id] = paths

        return all_paths

    def get_connected_components(self) -> List[Set[str]]:
        """
        Get weakly connected components in the graph.

        Returns:
            List of sets, where each set contains vulnerability IDs in a component
        """
        return list(nx.weakly_connected_components(self.graph))

    def get_source_nodes(self) -> List[str]:
        """
        Get nodes with no incoming edges (potential chain starting points).

        Returns:
            List of vulnerability IDs
        """
        return [node for node in self.graph.nodes() if self.graph.in_degree(node) == 0]

    def get_sink_nodes(self) -> List[str]:
        """
        Get nodes with no outgoing edges (potential chain ending points).

        Returns:
            List of vulnerability IDs
        """
        return [node for node in self.graph.nodes() if self.graph.out_degree(node) == 0]

    def get_critical_paths(self, min_risk: RiskLevel = RiskLevel.HIGH) -> List[List[str]]:
        """
        Get paths containing only high-risk vulnerabilities.

        Args:
            min_risk: Minimum risk level for critical paths

        Returns:
            List of critical paths
        """
        critical_nodes = [
            vuln_id for vuln_id, data in self.graph.nodes(data=True)
            if data.get('risk', 0) >= min_risk.value
        ]

        critical_paths = []
        for source in critical_nodes:
            for target in critical_nodes:
                if source != target:
                    paths = self.find_paths(source, target)
                    # Filter paths to only include critical nodes
                    for path in paths:
                        if all(node in critical_nodes for node in path):
                            critical_paths.append(path)

        return critical_paths

    def get_graph_stats(self) -> Dict[str, Any]:
        """
        Get statistics about the vulnerability graph.

        Returns:
            Dictionary containing graph statistics
        """
        return {
            'total_vulnerabilities': len(self._vulnerabilities),
            'total_links': len(self._links),
            'total_edges': self.graph.number_of_edges(),
            'total_nodes': self.graph.number_of_nodes(),
            'connected_components': len(self.get_connected_components()),
            'source_nodes': len(self.get_source_nodes()),
            'sink_nodes': len(self.get_sink_nodes()),
            'average_degree': sum(dict(self.graph.degree()).values()) / max(self.graph.number_of_nodes(), 1),
            'is_dag': nx.is_directed_acyclic_graph(self.graph),
            'density': nx.density(self.graph)
        }

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert graph to dictionary representation.

        Returns:
            Dictionary representation of the graph
        """
        return {
            'vulnerabilities': [v.to_dict() for v in self._vulnerabilities.values()],
            'links': [link.to_dict() for link in self._links],
            'stats': self.get_graph_stats()
        }

    def clear(self) -> None:
        """Clear all vulnerabilities and links from the graph."""
        self.graph.clear()
        self._vulnerabilities.clear()
        self._links.clear()
        logger.info("Graph cleared")

    def __len__(self) -> int:
        """Return the number of vulnerabilities in the graph."""
        return len(self._vulnerabilities)

    def __contains__(self, vuln_id: str) -> bool:
        """Check if a vulnerability exists in the graph."""
        return vuln_id in self._vulnerabilities

    def __repr__(self) -> str:
        """String representation of the graph."""
        return (f"VulnerabilityGraph(vulnerabilities={len(self._vulnerabilities)}, "
                f"links={len(self._links)})")
