"""
ChainScoring - Risk assessment and scoring for vulnerability chains.
"""

import logging
from typing import List, Dict, Optional
import numpy as np

from ..models import VulnerabilityChain, Vulnerability, ChainLink, ChainDetectionResult
from ..constants import RiskLevel, DEFAULT_CHAIN_WEIGHTS, ChainType

logger = logging.getLogger(__name__)


class ChainScoring:
    """
    Scoring system for assessing the risk of vulnerability chains.
    """

    def __init__(self, weights: Optional[Dict[str, float]] = None):
        """
        Initialize the scoring system.

        Args:
            weights: Custom weights for scoring factors (uses defaults if None)
        """
        self.weights = weights or DEFAULT_CHAIN_WEIGHTS.copy()

    def calculate_chain_risk(self, chain: VulnerabilityChain) -> float:
        """
        Calculate comprehensive risk score for a vulnerability chain.

        Args:
            chain: VulnerabilityChain to score

        Returns:
            Risk score (0-100)
        """
        # Component scores
        base_severity = self._calculate_base_severity(chain.vulnerabilities)
        chain_length_score = self._calculate_chain_length_score(chain)
        exploitability_score = self._calculate_exploitability(chain.links)
        impact_score = self._calculate_impact(chain)
        confidence_score = chain.confidence

        # Weighted combination
        risk_score = (
            base_severity * self.weights['base_severity'] +
            chain_length_score * self.weights['chain_length'] +
            exploitability_score * self.weights['exploitability'] +
            impact_score * self.weights['impact'] +
            confidence_score * self.weights['confidence']
        )

        # Apply chain type multiplier
        chain_type_multiplier = self._get_chain_type_multiplier(chain.chain_type)
        risk_score *= chain_type_multiplier

        # Normalize to 0-100 scale
        risk_score = min(100.0, max(0.0, risk_score))

        logger.debug(
            f"Chain risk calculated: {risk_score:.2f} "
            f"(base: {base_severity:.2f}, length: {chain_length_score:.2f}, "
            f"exploit: {exploitability_score:.2f}, impact: {impact_score:.2f})"
        )

        return risk_score

    def _calculate_base_severity(self, vulnerabilities: List[Vulnerability]) -> float:
        """
        Calculate base severity score from vulnerabilities.

        Args:
            vulnerabilities: List of vulnerabilities in chain

        Returns:
            Base severity score (0-10)
        """
        if not vulnerabilities:
            return 0.0

        # Get severity values
        severity_values = [v.risk.to_numeric() for v in vulnerabilities]

        # Use weighted average with emphasis on maximum severity
        max_severity = max(severity_values)
        avg_severity = np.mean(severity_values)

        # 70% max, 30% average
        base_severity = 0.7 * max_severity + 0.3 * avg_severity

        # Scale to 0-10
        return base_severity * 2.5

    def _calculate_chain_length_score(self, chain: VulnerabilityChain) -> float:
        """
        Calculate score based on chain length.

        Longer chains are generally more complex but also potentially more impactful.

        Args:
            chain: VulnerabilityChain

        Returns:
            Chain length score (0-10)
        """
        length = len(chain)

        if length <= 1:
            return 0.0
        elif length == 2:
            return 3.0
        elif length == 3:
            return 5.0
        elif length == 4:
            return 7.0
        else:  # 5+
            return 9.0

    def _calculate_exploitability(self, links: List[ChainLink]) -> float:
        """
        Calculate exploitability score from chain links.

        Args:
            links: List of chain links

        Returns:
            Exploitability score (0-10)
        """
        if not links:
            return 0.0

        # Get exploitability values from links
        exploitability_values = [link.exploitability for link in links]

        # Use minimum exploitability (weakest link in the chain)
        # But also consider average
        min_exploitability = min(exploitability_values)
        avg_exploitability = np.mean(exploitability_values)

        # 80% minimum (chain is as weak as weakest link)
        # 20% average
        combined_exploitability = 0.8 * min_exploitability + 0.2 * avg_exploitability

        # Scale to 0-10
        return combined_exploitability * 10.0

    def _calculate_impact(self, chain: VulnerabilityChain) -> float:
        """
        Calculate potential impact of the vulnerability chain.

        Args:
            chain: VulnerabilityChain

        Returns:
            Impact score (0-10)
        """
        # Base impact on chain type
        chain_type_impact = {
            ChainType.REMOTE_CODE_EXECUTION: 10.0,
            ChainType.PRIVILEGE_ESCALATION: 9.0,
            ChainType.DATA_EXFILTRATION: 8.5,
            ChainType.AUTHENTICATION_BYPASS: 8.0,
            ChainType.SESSION_HIJACKING: 7.5,
            ChainType.INFORMATION_GATHERING: 5.0,
            ChainType.COMPOUND_EXPLOIT: 7.0
        }

        base_impact = chain_type_impact.get(chain.chain_type, 5.0)

        # Adjust based on vulnerabilities
        has_high_risk = any(v.risk.value >= RiskLevel.HIGH.value for v in chain.vulnerabilities)
        has_critical_risk = any(v.risk.value >= RiskLevel.CRITICAL.value for v in chain.vulnerabilities)

        if has_critical_risk:
            base_impact *= 1.2
        elif has_high_risk:
            base_impact *= 1.1

        return min(10.0, base_impact)

    def _get_chain_type_multiplier(self, chain_type: ChainType) -> float:
        """
        Get multiplier based on chain type severity.

        Args:
            chain_type: Type of vulnerability chain

        Returns:
            Multiplier value
        """
        multipliers = {
            ChainType.REMOTE_CODE_EXECUTION: 1.5,
            ChainType.PRIVILEGE_ESCALATION: 1.4,
            ChainType.DATA_EXFILTRATION: 1.3,
            ChainType.AUTHENTICATION_BYPASS: 1.3,
            ChainType.SESSION_HIJACKING: 1.2,
            ChainType.INFORMATION_GATHERING: 0.9,
            ChainType.COMPOUND_EXPLOIT: 1.1
        }

        return multipliers.get(chain_type, 1.0)

    def score_all_chains(self, chains: List[VulnerabilityChain]) -> List[VulnerabilityChain]:
        """
        Calculate risk scores for all chains and update them.

        Args:
            chains: List of vulnerability chains

        Returns:
            List of chains with updated risk scores (sorted by score descending)
        """
        logger.info(f"Scoring {len(chains)} vulnerability chains")

        for chain in chains:
            chain.risk_score = self.calculate_chain_risk(chain)

        # Sort by risk score (highest first)
        sorted_chains = sorted(chains, key=lambda c: c.risk_score, reverse=True)

        logger.info("Chain scoring completed")
        return sorted_chains

    def score_detection_result(self, result: ChainDetectionResult) -> ChainDetectionResult:
        """
        Score all chains in a detection result and update it.

        Args:
            result: ChainDetectionResult to score

        Returns:
            Updated ChainDetectionResult with scored chains
        """
        result.chains = self.score_all_chains(result.chains)

        # Recalculate statistics
        result.critical_chains = sum(1 for chain in result.chains if chain.risk_score >= 15.0)
        result.high_risk_chains = sum(1 for chain in result.chains if chain.risk_score >= 10.0)

        return result

    def get_risk_distribution(self, chains: List[VulnerabilityChain]) -> Dict[str, int]:
        """
        Get distribution of chains across risk categories.

        Args:
            chains: List of vulnerability chains

        Returns:
            Dictionary mapping risk category to count
        """
        distribution = {
            'critical': 0,      # >= 15
            'high': 0,          # 10-15
            'medium': 0,        # 5-10
            'low': 0,           # < 5
        }

        for chain in chains:
            if chain.risk_score >= 15.0:
                distribution['critical'] += 1
            elif chain.risk_score >= 10.0:
                distribution['high'] += 1
            elif chain.risk_score >= 5.0:
                distribution['medium'] += 1
            else:
                distribution['low'] += 1

        return distribution

    def get_top_chains(
        self,
        chains: List[VulnerabilityChain],
        n: int = 10,
        min_risk: Optional[float] = None
    ) -> List[VulnerabilityChain]:
        """
        Get top N highest risk chains.

        Args:
            chains: List of vulnerability chains
            n: Number of top chains to return
            min_risk: Minimum risk score threshold

        Returns:
            List of top chains
        """
        # Filter by minimum risk if specified
        if min_risk is not None:
            chains = [c for c in chains if c.risk_score >= min_risk]

        # Sort by risk score
        sorted_chains = sorted(chains, key=lambda c: c.risk_score, reverse=True)

        # Return top N
        return sorted_chains[:n]

    def calculate_cvss_base_score(self, chain: VulnerabilityChain) -> float:
        """
        Calculate approximate CVSS v3 base score for a chain.

        This is a simplified approximation based on chain characteristics.

        Args:
            chain: VulnerabilityChain

        Returns:
            Approximate CVSS base score (0-10)
        """
        # Start with exploitability metrics
        attack_vector = 3.9  # Network (assume network-accessible)

        # Attack complexity based on chain length
        if len(chain) <= 2:
            attack_complexity = 0.77  # Low
        elif len(chain) <= 3:
            attack_complexity = 0.44  # High
        else:
            attack_complexity = 0.35  # Very High (not standard, but for chains)

        # Privileges required
        has_auth_bypass = any('auth' in v.name.lower() for v in chain.vulnerabilities)
        privileges_required = 0.85 if has_auth_bypass else 0.62  # None or Low

        # User interaction
        user_interaction = 0.85  # None (automated exploitation)

        # Impact metrics based on chain type
        if chain.chain_type == ChainType.REMOTE_CODE_EXECUTION:
            confidentiality = 0.56  # High
            integrity = 0.56        # High
            availability = 0.56     # High
        elif chain.chain_type == ChainType.PRIVILEGE_ESCALATION:
            confidentiality = 0.56
            integrity = 0.56
            availability = 0.22  # Low
        elif chain.chain_type == ChainType.DATA_EXFILTRATION:
            confidentiality = 0.56
            integrity = 0.22
            availability = 0.0   # None
        elif chain.chain_type == ChainType.AUTHENTICATION_BYPASS:
            confidentiality = 0.56
            integrity = 0.56
            availability = 0.22
        else:
            confidentiality = 0.22
            integrity = 0.22
            availability = 0.0

        # Calculate exploitability subscore
        exploitability = 8.22 * attack_vector * attack_complexity * privileges_required * user_interaction

        # Calculate impact subscore
        impact_base = 1 - ((1 - confidentiality) * (1 - integrity) * (1 - availability))
        impact = 6.42 * impact_base

        # Calculate base score
        if impact <= 0:
            cvss_score = 0.0
        else:
            cvss_score = min(10.0, ((impact + exploitability) * 1.08))

        return round(cvss_score, 1)

    def get_scoring_summary(self, chains: List[VulnerabilityChain]) -> Dict[str, any]:
        """
        Get summary statistics about scored chains.

        Args:
            chains: List of scored chains

        Returns:
            Dictionary with scoring statistics
        """
        if not chains:
            return {
                'total_chains': 0,
                'average_risk': 0.0,
                'max_risk': 0.0,
                'min_risk': 0.0,
                'risk_distribution': {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
            }

        risk_scores = [c.risk_score for c in chains]

        return {
            'total_chains': len(chains),
            'average_risk': np.mean(risk_scores),
            'max_risk': max(risk_scores),
            'min_risk': min(risk_scores),
            'median_risk': np.median(risk_scores),
            'std_risk': np.std(risk_scores),
            'risk_distribution': self.get_risk_distribution(chains)
        }

    def __repr__(self) -> str:
        """String representation of the scoring system."""
        return f"ChainScoring(weights={self.weights})"
