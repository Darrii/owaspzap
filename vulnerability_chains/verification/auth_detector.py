"""
Authentication Detection Module

Automatically detects authentication requirements for web applications
by analyzing responses and scan results.
"""

import re
import logging
from typing import Dict, Optional, List
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)


class AuthType(Enum):
    """Types of authentication methods."""
    NONE = "none"
    FORM = "form"
    TOKEN = "token"
    BASIC = "basic"
    COOKIE = "cookie"


@dataclass
class AuthConfig:
    """Authentication configuration detected from target."""
    auth_type: AuthType
    login_url: Optional[str] = None
    csrf_required: bool = False
    csrf_field: Optional[str] = None
    csrf_pattern: Optional[str] = None
    session_cookie_name: Optional[str] = None
    auth_headers: Optional[Dict[str, str]] = None
    requires_setup: bool = False
    setup_url: Optional[str] = None


class AuthenticationDetector:
    """
    Automatically detect authentication requirements for web applications.

    Supports:
    - Form-based authentication (Django, Laravel, WordPress, DVWA)
    - Token-based authentication (JWT, Bearer tokens)
    - Basic authentication
    - Cookie-based authentication
    - No authentication
    """

    # Common CSRF token patterns: (pattern, field_name)
    CSRF_PATTERNS = [
        # Django
        (r'name=["\']csrfmiddlewaretoken["\'] value=["\']([^"\']+)["\']', 'csrfmiddlewaretoken'),
        # Laravel
        (r'name=["\']_token["\'] value=["\']([^"\']+)["\']', '_token'),
        # Rails
        (r'name=["\']authenticity_token["\'] value=["\']([^"\']+)["\']', 'authenticity_token'),
        # DVWA
        (r'name=["\']user_token["\'] value=["\']([^"\']+)["\']', 'user_token'),
        # Generic
        (r'name=["\']csrf_token["\'] value=["\']([^"\']+)["\']', 'csrf_token'),
        (r'name=["\']_csrf["\'] value=["\']([^"\']+)["\']', '_csrf'),
    ]

    # Common login form patterns
    LOGIN_FORM_PATTERNS = [
        r'<form[^>]*action=["\']([^"\']*login[^"\']*)["\']',
        r'<form[^>]*action=["\']([^"\']*signin[^"\']*)["\']',
        r'<form[^>]*action=["\']([^"\']*auth[^"\']*)["\']',
    ]

    # Setup/initialization indicators
    SETUP_INDICATORS = {
        'dvwa': ['/setup.php', 'Database not setup', 'Setup / Reset Database'],
        'wordpress': ['wp-admin/install.php', 'Error establishing a database connection'],
        'drupal': ['/install.php', 'Drupal installation'],
        'joomla': ['/installation/', 'Joomla! Installation'],
    }

    def detect_auth_type(self, target_url: str, initial_response=None) -> AuthConfig:
        """
        Analyze target and detect authentication requirements.

        Args:
            target_url: Target application URL
            initial_response: Optional initial HTTP response

        Returns:
            AuthConfig with detected authentication configuration
        """
        logger.info(f"Detecting authentication type for {target_url}")

        if initial_response is None:
            import requests
            try:
                initial_response = requests.get(target_url, timeout=10, allow_redirects=True)
            except Exception as e:
                logger.warning(f"Failed to fetch {target_url}: {e}")
                return AuthConfig(auth_type=AuthType.NONE)

        # Check for setup requirements first
        setup_config = self._detect_setup_requirements(target_url, initial_response)
        if setup_config:
            return setup_config

        # Check for Basic Auth
        if self._is_basic_auth(initial_response):
            return self._detect_basic_auth(target_url, initial_response)

        # Check for Token Auth (JWT, Bearer)
        if self._is_token_auth(initial_response):
            return self._detect_token_auth(target_url, initial_response)

        # Check for Form Auth
        if self._is_form_auth(initial_response):
            return self._detect_form_auth(target_url, initial_response)

        # No authentication detected
        logger.info("No authentication detected")
        return AuthConfig(auth_type=AuthType.NONE)

    def _detect_setup_requirements(self, target_url: str, response) -> Optional[AuthConfig]:
        """
        Detect if application requires initialization/setup.

        Returns AuthConfig with requires_setup=True if setup needed.
        """
        # Check for redirect to setup page
        if response.status_code == 302:
            location = response.headers.get('Location', '')
            for app_type, indicators in self.SETUP_INDICATORS.items():
                if any(indicator in location for indicator in indicators):
                    logger.info(f"Detected {app_type} setup requirement")
                    return AuthConfig(
                        auth_type=AuthType.FORM,  # Setup usually requires form auth after
                        requires_setup=True,
                        setup_url=location if location.startswith('http') else f"{target_url.rstrip('/')}/{location.lstrip('/')}"
                    )

        # Check response content for setup indicators
        response_text = response.text.lower()
        for app_type, indicators in self.SETUP_INDICATORS.items():
            if any(indicator.lower() in response_text for indicator in indicators):
                logger.info(f"Detected {app_type} setup requirement in content")
                # Try to find setup URL
                setup_url = None
                for indicator in indicators:
                    if indicator.startswith('/'):
                        setup_url = f"{target_url.rstrip('/')}{indicator}"
                        break

                return AuthConfig(
                    auth_type=AuthType.FORM,
                    requires_setup=True,
                    setup_url=setup_url
                )

        return None

    def _is_basic_auth(self, response) -> bool:
        """Check if response indicates Basic authentication."""
        if response.status_code == 401:
            www_auth = response.headers.get('WWW-Authenticate', '')
            return 'Basic' in www_auth
        return False

    def _is_token_auth(self, response) -> bool:
        """Check if response indicates Token authentication (JWT, Bearer)."""
        # Look for Authorization header requirements
        www_auth = response.headers.get('WWW-Authenticate', '')
        if 'Bearer' in www_auth:
            return True

        # Look for token endpoints in response
        if re.search(r'/api/auth|/api/token|/oauth', response.text, re.IGNORECASE):
            return True

        return False

    def _is_form_auth(self, response) -> bool:
        """Check if response indicates Form authentication."""
        # Look for login forms
        return bool(re.search(r'<form[^>]*>.*?(username|email|login).*?password.*?</form>',
                             response.text, re.IGNORECASE | re.DOTALL))

    def _detect_basic_auth(self, target_url: str, response) -> AuthConfig:
        """Detect Basic authentication configuration."""
        logger.info("Detected Basic authentication")
        return AuthConfig(
            auth_type=AuthType.BASIC,
            auth_headers={'Authorization': 'Basic {credentials}'}
        )

    def _detect_token_auth(self, target_url: str, response) -> AuthConfig:
        """Detect Token authentication configuration."""
        logger.info("Detected Token authentication")

        # Try to find token endpoint
        token_url = None
        for pattern in [r'/api/auth', r'/api/token', r'/oauth/token']:
            match = re.search(pattern, response.text, re.IGNORECASE)
            if match:
                token_url = f"{target_url.rstrip('/')}{match.group()}"
                break

        return AuthConfig(
            auth_type=AuthType.TOKEN,
            login_url=token_url,
            auth_headers={'Authorization': 'Bearer {token}'}
        )

    def _detect_form_auth(self, target_url: str, response) -> AuthConfig:
        """Detect Form authentication configuration."""
        logger.info("Detected Form authentication")

        # Find login form action URL
        login_url = None
        for pattern in self.LOGIN_FORM_PATTERNS:
            match = re.search(pattern, response.text, re.IGNORECASE)
            if match:
                action = match.group(1)
                if action.startswith('http'):
                    login_url = action
                elif action.startswith('/'):
                    login_url = f"{target_url.rstrip('/')}{action}"
                else:
                    login_url = f"{target_url.rstrip('/')}/{action}"
                break

        # If no explicit login form, try common paths
        if not login_url:
            # Check if we're already on a login page
            if 'login' in response.url.lower():
                login_url = response.url
            else:
                # Try common login paths
                login_url = f"{target_url.rstrip('/')}/login.php"

        # Detect CSRF requirement
        csrf_required = False
        csrf_field = None
        csrf_pattern = None

        for pattern, field_name in self.CSRF_PATTERNS:
            match = re.search(pattern, response.text)
            if match:
                csrf_required = True
                csrf_field = field_name
                csrf_pattern = pattern
                logger.info(f"Detected CSRF token requirement: {csrf_field}")
                break

        return AuthConfig(
            auth_type=AuthType.FORM,
            login_url=login_url,
            csrf_required=csrf_required,
            csrf_field=csrf_field,
            csrf_pattern=csrf_pattern,
            session_cookie_name='PHPSESSID'  # Default, will be detected from actual response
        )

    def detect_csrf_field(self, html: str) -> Optional[str]:
        """
        Detect CSRF field name from HTML.

        Args:
            html: HTML content to analyze

        Returns:
            CSRF field name if found
        """
        for pattern, field_name in self.CSRF_PATTERNS:
            match = re.search(pattern, html)
            if match:
                return field_name
        return None

    def extract_csrf_token(self, html: str, pattern: Optional[str] = None) -> Optional[str]:
        """
        Extract CSRF token from HTML.

        Args:
            html: HTML content
            pattern: Optional specific pattern to use

        Returns:
            CSRF token value if found
        """
        if pattern:
            # Single pattern provided
            match = re.search(pattern, html)
            if match:
                return match.group(1)
        else:
            # Try all patterns
            for pat, _ in self.CSRF_PATTERNS:
                match = re.search(pat, html)
                if match:
                    return match.group(1)

        return None
