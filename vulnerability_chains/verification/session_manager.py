"""
Session Management Module

Manages authenticated sessions for different authentication types.
Handles CSRF tokens, cookies, and session validation.
"""

import requests
import re
import logging
from typing import Dict, Optional, Any
from .auth_detector import AuthConfig, AuthType

logger = logging.getLogger(__name__)


class SessionError(Exception):
    """Raised when session creation or management fails."""
    pass


class SessionManager:
    """
    Manages authenticated sessions for web applications.

    Supports:
    - Form-based authentication with CSRF handling
    - Token-based authentication (JWT, Bearer)
    - Basic authentication
    - Cookie-based authentication
    """

    def __init__(self):
        self.sessions: Dict[str, requests.Session] = {}

    def create_session(
        self,
        auth_config: AuthConfig,
        credentials: Optional[Dict[str, str]] = None,
        target_url: Optional[str] = None
    ) -> requests.Session:
        """
        Create authenticated session based on detected auth type.

        Args:
            auth_config: Authentication configuration
            credentials: User credentials (username/password or token)
            target_url: Target application URL

        Returns:
            Authenticated requests.Session

        Raises:
            SessionError: If authentication fails
        """
        logger.info(f"Creating session with auth type: {auth_config.auth_type.value}")

        if auth_config.auth_type == AuthType.NONE:
            return self._create_unauthenticated_session()

        elif auth_config.auth_type == AuthType.FORM:
            return self._create_form_session(auth_config, credentials, target_url)

        elif auth_config.auth_type == AuthType.TOKEN:
            return self._create_token_session(auth_config, credentials)

        elif auth_config.auth_type == AuthType.BASIC:
            return self._create_basic_session(auth_config, credentials)

        elif auth_config.auth_type == AuthType.COOKIE:
            return self._create_cookie_session(auth_config, credentials)

        else:
            raise SessionError(f"Unsupported auth type: {auth_config.auth_type}")

    def _create_unauthenticated_session(self) -> requests.Session:
        """Create session without authentication."""
        logger.info("Creating unauthenticated session")
        return requests.Session()

    def _create_form_session(
        self,
        auth_config: AuthConfig,
        credentials: Optional[Dict[str, str]],
        target_url: Optional[str]
    ) -> requests.Session:
        """
        Create session with form-based authentication.

        Handles CSRF tokens automatically.
        """
        if not credentials:
            raise SessionError("Credentials required for form authentication")

        if not auth_config.login_url:
            raise SessionError("Login URL not provided")

        session = requests.Session()

        try:
            # Handle setup requirements if needed
            if auth_config.requires_setup:
                logger.info("Performing application setup before authentication")
                self._handle_setup(session, auth_config, target_url)

            # Get login page to extract CSRF token
            logger.info(f"Fetching login page: {auth_config.login_url}")
            login_page = session.get(auth_config.login_url)

            # Extract CSRF token if required
            csrf_token = None
            if auth_config.csrf_required:
                from .auth_detector import AuthenticationDetector
                detector = AuthenticationDetector()
                csrf_token = detector.extract_csrf_token(
                    login_page.text,
                    auth_config.csrf_pattern
                )

                if not csrf_token:
                    logger.warning("CSRF token extraction failed, attempting without it")
                else:
                    logger.info(f"Extracted CSRF token: {csrf_token[:20]}...")

            # Build login data
            login_data = {
                'username': credentials.get('username', 'admin'),
                'password': credentials.get('password', 'password'),
                'Login': 'Login',  # Common submit field
            }

            # Add CSRF token if present
            if csrf_token and auth_config.csrf_field:
                login_data[auth_config.csrf_field] = csrf_token

            # Perform login
            logger.info("Attempting login...")
            login_response = session.post(
                auth_config.login_url,
                data=login_data,
                allow_redirects=True
            )

            # Verify login success
            if self._verify_login_success(login_response, auth_config.login_url):
                logger.info("✓ Login successful")
                return session
            else:
                raise SessionError("Login failed - still on login page or error response")

        except Exception as e:
            logger.error(f"Form authentication failed: {e}")
            raise SessionError(f"Form authentication failed: {e}")

    def _handle_setup(
        self,
        session: requests.Session,
        auth_config: AuthConfig,
        target_url: Optional[str]
    ):
        """
        Handle application setup/initialization (DVWA, WordPress, etc.).

        This is OPTIONAL - only for test environments.
        """
        if not auth_config.setup_url:
            logger.warning("Setup required but no setup URL provided")
            return

        logger.info(f"Accessing setup page: {auth_config.setup_url}")

        try:
            # Get setup page
            setup_response = session.get(auth_config.setup_url)

            # Extract CSRF token from setup page
            from .auth_detector import AuthenticationDetector
            detector = AuthenticationDetector()
            csrf_token = detector.extract_csrf_token(setup_response.text)

            if not csrf_token:
                logger.warning("Could not extract CSRF token from setup page")
                return

            logger.info(f"Extracted setup CSRF token: {csrf_token[:20]}...")

            # Perform database creation/setup
            setup_data = {
                'create_db': 'Create / Reset Database',
                'user_token': csrf_token
            }

            setup_result = session.post(
                auth_config.setup_url,
                data=setup_data,
                allow_redirects=True
            )

            # Check for success indicators
            success_indicators = [
                'setup successful',
                'database has been created',
                'created successfully',
                'setup has been completed'
            ]

            if any(indicator in setup_result.text.lower() for indicator in success_indicators):
                logger.info("✓ Setup completed successfully")
            else:
                logger.warning("Setup result unclear")

        except Exception as e:
            logger.warning(f"Setup failed: {e}")

    def _create_token_session(
        self,
        auth_config: AuthConfig,
        credentials: Optional[Dict[str, str]]
    ) -> requests.Session:
        """Create session with token-based authentication (JWT, Bearer)."""
        if not credentials:
            raise SessionError("Credentials required for token authentication")

        session = requests.Session()

        try:
            # Get token from authentication endpoint
            if auth_config.login_url:
                token_data = {
                    'username': credentials.get('username'),
                    'password': credentials.get('password')
                }

                token_response = session.post(auth_config.login_url, json=token_data)

                if token_response.status_code == 200:
                    token_json = token_response.json()
                    token = token_json.get('token') or token_json.get('access_token')

                    if token:
                        # Add token to session headers
                        session.headers['Authorization'] = f'Bearer {token}'
                        logger.info("✓ Token authentication successful")
                        return session

            raise SessionError("Token authentication failed")

        except Exception as e:
            logger.error(f"Token authentication failed: {e}")
            raise SessionError(f"Token authentication failed: {e}")

    def _create_basic_session(
        self,
        auth_config: AuthConfig,
        credentials: Optional[Dict[str, str]]
    ) -> requests.Session:
        """Create session with HTTP Basic authentication."""
        if not credentials:
            raise SessionError("Credentials required for basic authentication")

        session = requests.Session()
        session.auth = (
            credentials.get('username', 'admin'),
            credentials.get('password', 'password')
        )

        logger.info("✓ Basic authentication configured")
        return session

    def _create_cookie_session(
        self,
        auth_config: AuthConfig,
        credentials: Optional[Dict[str, str]]
    ) -> requests.Session:
        """Create session with cookie-based authentication."""
        session = requests.Session()

        if credentials and 'cookies' in credentials:
            # Set cookies from provided dict
            for name, value in credentials['cookies'].items():
                session.cookies.set(name, value)

            logger.info("✓ Cookie authentication configured")

        return session

    def _verify_login_success(self, response, login_url: str) -> bool:
        """
        Verify that login was successful.

        Checks:
        - Not redirected back to login page
        - Response status is 200 or redirect
        - Response doesn't contain login form
        """
        # Check for common success indicators FIRST
        # (DVWA redirects back to login.php after successful login)
        success_indicators = [
            'logout',
            'dashboard',
            'welcome',
            'profile',
            'account'
        ]

        response_lower = response.text.lower()
        if any(indicator in response_lower for indicator in success_indicators):
            return True

        # If response contains login form again with username field, login failed
        if re.search(r'<form[^>]*>.*?password.*?</form>', response.text, re.IGNORECASE | re.DOTALL):
            # Could be the user settings page, check for username field
            if re.search(r'name=["\']username["\']', response.text, re.IGNORECASE):
                return False

        # If we got here and status is 200, assume success
        return response.status_code in [200, 302]

    def set_security_level(
        self,
        session: requests.Session,
        target_url: str,
        level: str = 'low'
    ) -> bool:
        """
        Set security level (for DVWA and similar test applications).

        This is OPTIONAL - only for test environments.

        Args:
            session: Authenticated session
            target_url: Target application URL
            level: Security level ('low', 'medium', 'high', 'impossible')

        Returns:
            True if security level was set successfully
        """
        try:
            security_url = f"{target_url.rstrip('/')}/security.php"

            logger.info(f"Setting security level to '{level}'...")

            # Get security page to extract CSRF token (DVWA 'impossible' level requires it)
            security_page = session.get(security_url)

            # Extract CSRF token
            csrf_token = None
            from .auth_detector import AuthenticationDetector
            detector = AuthenticationDetector()
            csrf_token = detector.extract_csrf_token(security_page.text)

            # Build form data
            form_data = {
                'security': level,
                'seclev_submit': 'Submit'
            }

            # Add CSRF token if present
            if csrf_token:
                form_data['user_token'] = csrf_token
                logger.info(f"Using CSRF token for security level change")

            response = session.post(security_url, data=form_data, allow_redirects=True)

            # Verify security level was set via cookie
            if 'security' in session.cookies.get_dict():
                actual_level = session.cookies.get('security')
                if actual_level == level:
                    logger.info(f"✓ Security level set to '{level}'")
                    return True
                else:
                    logger.warning(f"Security level is '{actual_level}' (expected '{level}')")
                    return False

            logger.warning("Security cookie not found")
            return False

        except Exception as e:
            logger.warning(f"Failed to set security level: {e}")
            return False
