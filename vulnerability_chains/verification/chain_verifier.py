"""
Chain Verification Module

Automatically verifies that detected vulnerability chains are exploitable.
Uses exact URLs and payloads from scanner results.
"""

import requests
import logging
import re
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from datetime import datetime

from ..models import VulnerabilityChain, Vulnerability
from .auth_detector import AuthenticationDetector, AuthConfig
from .session_manager import SessionManager, SessionError

logger = logging.getLogger(__name__)


@dataclass
class VulnerabilityTestResult:
    """Result of testing a single vulnerability."""
    vuln_name: str
    vuln_url: str
    tested: bool
    verified: bool
    confidence: float
    evidence_found: bool
    response_code: Optional[int] = None
    error: Optional[str] = None


@dataclass
class ChainVerificationResult:
    """Result of verifying a vulnerability chain."""
    chain_id: str
    verified: bool
    confidence: float
    total_vulns: int
    verified_vulns: int
    test_results: List[VulnerabilityTestResult]
    exploitation_path: List[str]
    failures: List[str]
    timestamp: datetime


class ChainVerifier:
    """
    Automatically verify vulnerability chains.

    Features:
    - Smart authentication detection
    - CSRF token handling
    - Exact payload testing from scanner results
    - Confidence scoring
    """

    def __init__(self):
        self.auth_detector = AuthenticationDetector()
        self.session_manager = SessionManager()

    def verify_chain(
        self,
        chain: VulnerabilityChain,
        scan_alerts: List[Dict[str, Any]],
        target_url: str,
        credentials: Optional[Dict[str, str]] = None
    ) -> ChainVerificationResult:
        """
        Automatically verify a vulnerability chain.

        Args:
            chain: Vulnerability chain to verify
            scan_alerts: Raw scan results (for exact URLs/payloads)
            target_url: Target application URL
            credentials: Optional authentication credentials

        Returns:
            ChainVerificationResult with verification status
        """
        logger.info(f"Verifying chain {chain.id} (Risk: {chain.risk_score})")

        test_results = []
        exploitation_path = []
        failures = []

        try:
            # Step 1: Detect authentication requirements
            logger.info("Step 1: Detecting authentication requirements...")
            initial_response = requests.get(target_url, timeout=10, allow_redirects=True)
            auth_config = self.auth_detector.detect_auth_type(target_url, initial_response)

            logger.info(f"Detected auth type: {auth_config.auth_type.value}")

            # Step 2: Create authenticated session
            logger.info("Step 2: Creating authenticated session...")
            try:
                session = self.session_manager.create_session(
                    auth_config,
                    credentials or self._get_default_credentials(target_url),
                    target_url
                )
            except SessionError as e:
                logger.warning(f"Session creation failed: {e}")
                # Try without authentication
                session = requests.Session()

            # Step 3: Set security level if needed (for test apps)
            # DVWA detection: check for localhost:8080 or 'dvwa' in URL
            if 'dvwa' in target_url.lower() or 'localhost:8080' in target_url.lower():
                logger.info("Detected DVWA - setting security level to 'low'")
                self.session_manager.set_security_level(session, target_url, 'low')

            # Step 4: Verify each vulnerability in the chain
            logger.info(f"Step 3: Testing {len(chain.vulnerabilities)} vulnerabilities...")

            for i, vuln in enumerate(chain.vulnerabilities, 1):
                logger.info(f"  Testing vulnerability {i}/{len(chain.vulnerabilities)}: {vuln.name}")

                test_result = self._verify_vulnerability(
                    vuln,
                    session,
                    scan_alerts,
                    target_url
                )

                test_results.append(test_result)

                if test_result.verified:
                    exploitation_path.append(f"{vuln.name} at {vuln.url}")
                else:
                    failures.append(f"{vuln.name}: {test_result.error or 'Not verified'}")

            # Step 5: Calculate overall verification
            verified_count = sum(1 for r in test_results if r.verified)
            total_count = len(test_results)

            # Chain is verified if:
            # - At least 50% of vulnerabilities verified, OR
            # - Last vulnerability in chain is verified (most critical), OR
            # - Chain contains critical standalone vulnerabilities
            chain_verified = (
                verified_count >= total_count * 0.5 or
                (test_results and test_results[-1].verified) or
                self._has_critical_standalone_vuln(chain, test_results)
            )

            # Calculate confidence
            if verified_count == 0:
                confidence = 0.0
            elif verified_count == total_count:
                confidence = 1.0
            else:
                # Partial verification
                confidence = verified_count / total_count * 0.8  # Max 0.8 for partial

            logger.info(f"Verification complete: {verified_count}/{total_count} vulns verified")
            logger.info(f"Chain verified: {chain_verified}, Confidence: {confidence:.2f}")

            return ChainVerificationResult(
                chain_id=chain.id,
                verified=chain_verified,
                confidence=confidence,
                total_vulns=total_count,
                verified_vulns=verified_count,
                test_results=test_results,
                exploitation_path=exploitation_path,
                failures=failures,
                timestamp=datetime.now()
            )

        except Exception as e:
            logger.error(f"Chain verification failed: {e}")
            return ChainVerificationResult(
                chain_id=chain.id,
                verified=False,
                confidence=0.0,
                total_vulns=len(chain.vulnerabilities),
                verified_vulns=0,
                test_results=test_results,
                exploitation_path=[],
                failures=[f"Verification error: {str(e)}"],
                timestamp=datetime.now()
            )

    def _verify_vulnerability(
        self,
        vuln: Vulnerability,
        session: requests.Session,
        scan_alerts: List[Dict[str, Any]],
        target_url: str
    ) -> VulnerabilityTestResult:
        """
        Verify a single vulnerability using exact scanner data.

        Args:
            vuln: Vulnerability to verify
            session: Authenticated session
            scan_alerts: Raw scan results
            target_url: Target application URL

        Returns:
            VulnerabilityTestResult
        """
        try:
            # Extract exact details from scan alerts
            exact_details = self._extract_exact_vuln_details(vuln, scan_alerts)

            if not exact_details:
                return VulnerabilityTestResult(
                    vuln_name=vuln.name,
                    vuln_url=vuln.url,
                    tested=False,
                    verified=False,
                    confidence=0.0,
                    evidence_found=False,
                    error="Exact details not found in scan results"
                )

            # Use exact URL from scanner
            test_url = exact_details['url']

            # Replace scanner hostname with actual target hostname
            test_url = self._normalize_url(test_url, target_url)

            # Test the vulnerability
            response = session.get(test_url, timeout=10, allow_redirects=True)

            # Check if evidence is present in response
            evidence = exact_details.get('evidence', '')
            evidence_found = evidence in response.text if evidence else False

            # For some vulnerability types, check other indicators
            verified = evidence_found or self._check_vuln_indicators(
                vuln,
                response,
                exact_details
            )

            confidence = 1.0 if verified else 0.0

            return VulnerabilityTestResult(
                vuln_name=vuln.name,
                vuln_url=test_url,
                tested=True,
                verified=verified,
                confidence=confidence,
                evidence_found=evidence_found,
                response_code=response.status_code
            )

        except Exception as e:
            logger.warning(f"Failed to verify {vuln.name}: {e}")
            return VulnerabilityTestResult(
                vuln_name=vuln.name,
                vuln_url=vuln.url,
                tested=False,
                verified=False,
                confidence=0.0,
                evidence_found=False,
                error=str(e)
            )

    def _extract_exact_vuln_details(
        self,
        vuln: Vulnerability,
        scan_alerts: List[Dict[str, Any]]
    ) -> Optional[Dict[str, Any]]:
        """
        Extract exact vulnerability details from scanner results.

        Tries multiple matching strategies:
        1. Match by plugin ID + URL + param (most specific)
        2. Match by normalized name + URL + param
        3. Match by URL + param (for missing headers)
        4. Match by URL only (fallback)
        """
        # Import normalization function
        from ..models import Vulnerability as VulnModel

        # Strategy 1: Match by plugin ID + URL + param (most reliable)
        for alert in scan_alerts:
            vuln_plugin_id = vuln.plugin_id
            alert_plugin_id = alert.get('pluginid')

            if vuln_plugin_id and alert_plugin_id and str(vuln_plugin_id) == str(alert_plugin_id):
                # Check URL match (normalize both)
                if self._urls_match(vuln.url, alert.get('url', '')):
                    # Check param match
                    vuln_param = vuln.param or ''
                    alert_param = alert.get('param', '')
                    if vuln_param == alert_param:
                        logger.info(f"  Matched by plugin ID: {vuln.name} at {alert.get('url')}")
                        return {
                            'url': alert.get('url'),
                            'method': alert.get('method', 'GET'),
                            'param': alert.get('param', ''),
                            'attack': alert.get('attack', ''),
                            'evidence': alert.get('evidence', ''),
                            'risk': alert.get('risk')
                        }

        # Strategy 2: Match by normalized name + URL + param
        for alert in scan_alerts:
            # Normalize the alert name
            normalized_alert_name = VulnModel._normalize_vulnerability_name(alert.get('name', ''))

            if normalized_alert_name == vuln.name:
                # Check URL match
                if self._urls_match(vuln.url, alert.get('url', '')):
                    # Check param match
                    vuln_param = vuln.param or ''
                    alert_param = alert.get('param', '')
                    if vuln_param == alert_param:
                        logger.info(f"  Matched by normalized name: {vuln.name} at {alert.get('url')}")
                        return {
                            'url': alert.get('url'),
                            'method': alert.get('method', 'GET'),
                            'param': alert.get('param', ''),
                            'attack': alert.get('attack', ''),
                            'evidence': alert.get('evidence', ''),
                            'risk': alert.get('risk')
                        }

        # Strategy 3: Match by URL + param (for vulnerabilities without specific names)
        for alert in scan_alerts:
            if self._urls_match(vuln.url, alert.get('url', '')):
                vuln_param = vuln.param or ''
                alert_param = alert.get('param', '')
                if vuln_param == alert_param:
                    logger.info(f"  Matched by URL+param: {vuln.name} at {alert.get('url')}")
                    return {
                        'url': alert.get('url'),
                        'method': alert.get('method', 'GET'),
                        'param': alert.get('param', ''),
                        'attack': alert.get('attack', ''),
                        'evidence': alert.get('evidence', ''),
                        'risk': alert.get('risk')
                    }

        # Strategy 4: Fallback - match by URL only (for missing headers)
        if 'missing' in vuln.name.lower() and 'header' in vuln.name.lower():
            for alert in scan_alerts:
                if self._urls_match(vuln.url, alert.get('url', '')):
                    logger.info(f"  Matched by URL (missing header): {vuln.name} at {alert.get('url')}")
                    return {
                        'url': alert.get('url'),
                        'method': alert.get('method', 'GET'),
                        'param': alert.get('param', ''),
                        'attack': alert.get('attack', ''),
                        'evidence': alert.get('evidence', ''),
                        'risk': alert.get('risk')
                    }

        logger.warning(f"  Could not find exact details for {vuln.name} at {vuln.url}")
        return None

    def _urls_match(self, url1: str, url2: str) -> bool:
        """
        Check if two URLs match, ignoring hostname differences.

        Example:
            url1: http://dvwa/vulnerabilities/xss
            url2: http://localhost:8080/vulnerabilities/xss
            Returns: True
        """
        # Extract paths from URLs
        def extract_path(url):
            if '://' in url:
                parts = url.split('/', 3)
                return '/' + parts[3] if len(parts) > 3 else '/'
            return url

        path1 = extract_path(url1)
        path2 = extract_path(url2)

        return path1 == path2

    def _normalize_url(self, scanner_url: str, target_url: str) -> str:
        """
        Normalize scanner URL to match target hostname.

        Example:
            scanner_url: http://dvwa/vulnerabilities/xss
            target_url: http://localhost:8080
            result: http://localhost:8080/vulnerabilities/xss
        """
        # Extract path from scanner URL
        if '://' in scanner_url:
            parts = scanner_url.split('/', 3)
            if len(parts) > 3:
                path = '/' + parts[3]
            else:
                path = '/'
        else:
            path = scanner_url

        # Combine with target URL
        return target_url.rstrip('/') + path

    def _check_vuln_indicators(
        self,
        vuln: Vulnerability,
        response: requests.Response,
        exact_details: Dict[str, Any]
    ) -> bool:
        """
        Check for vulnerability indicators beyond exact evidence.

        Different vulnerability types have different indicators.
        """
        vuln_name_lower = vuln.name.lower()

        # Missing headers - check if headers are missing
        if 'missing' in vuln_name_lower and 'header' in vuln_name_lower:
            param = exact_details.get('param', '').lower()
            return param not in [h.lower() for h in response.headers.keys()]

        # XSS - check if script tags or payload patterns are reflected
        if 'xss' in vuln_name_lower or 'cross site scripting' in vuln_name_lower:
            return '<script' in response.text.lower() or 'alert(' in response.text.lower()

        # SQL Injection - check for SQL error messages
        if 'sql' in vuln_name_lower:
            sql_indicators = ['sql syntax', 'mysql', 'postgresql', 'sqlite', 'error in your sql']
            return any(indicator in response.text.lower() for indicator in sql_indicators)

        # CORS - check Access-Control-Allow-Origin header
        if 'cors' in vuln_name_lower or 'cross-domain' in vuln_name_lower:
            cors_header = response.headers.get('Access-Control-Allow-Origin', '')
            return cors_header == '*'

        # Session ID in URL - check for session parameters
        if 'session id' in vuln_name_lower and 'url' in vuln_name_lower:
            return 'sid=' in response.url or 'sessionid=' in response.url.lower()

        # Information disclosure - check for sensitive info patterns
        if 'information disclosure' in vuln_name_lower or 'directory listing' in vuln_name_lower:
            return 'parent directory' in response.text.lower() or '<title>Index of' in response.text

        # Spring Actuator - check if endpoint is accessible
        if 'actuator' in vuln_name_lower or 'spring' in vuln_name_lower:
            return response.status_code == 200 and ('actuator' in response.text.lower() or '"status"' in response.text)

        # Default: response status is 200
        return response.status_code == 200

    def _has_critical_standalone_vuln(
        self,
        chain: VulnerabilityChain,
        test_results: List[VulnerabilityTestResult]
    ) -> bool:
        """
        Check if chain contains critical standalone vulnerabilities.

        Some vulnerabilities are CRITICAL even without the full chain:
        - Spring Actuator exposure
        - AWS metadata endpoint exposure
        - Debug endpoints enabled
        """
        critical_standalone = [
            'spring actuator',
            'actuator information leak',
            'aws metadata',
            'debug',
            '.git disclosure'
        ]

        for i, vuln in enumerate(chain.vulnerabilities):
            if any(keyword in vuln.name.lower() for keyword in critical_standalone):
                # Check if this vuln is verified
                if i < len(test_results) and test_results[i].verified:
                    logger.info(f"Found critical standalone vulnerability: {vuln.name}")
                    return True

        return False

    def _get_default_credentials(self, target_url: str) -> Dict[str, str]:
        """Get default credentials based on target URL."""
        # Common default credentials for test applications
        if 'dvwa' in target_url.lower():
            return {'username': 'admin', 'password': 'password'}
        elif 'wordpress' in target_url.lower():
            return {'username': 'admin', 'password': 'admin'}
        elif 'drupal' in target_url.lower():
            return {'username': 'admin', 'password': 'admin'}
        else:
            return {'username': 'admin', 'password': 'password'}
