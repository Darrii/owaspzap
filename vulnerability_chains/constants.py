"""
Constants and enumerations for vulnerability chain detection.
"""

from enum import Enum
from typing import Dict, List

class VulnerabilityType(Enum):
    """Enumeration of vulnerability types from OWASP ZAP."""

    # Injection vulnerabilities
    XSS = "Cross Site Scripting"
    SQL_INJECTION = "SQL Injection"
    COMMAND_INJECTION = "Command Injection"
    LDAP_INJECTION = "LDAP Injection"
    XPATH_INJECTION = "XPath Injection"

    # Authentication & Session
    AUTH_BYPASS = "Authentication Bypass"
    SESSION_FIXATION = "Session Fixation"
    WEAK_AUTH = "Weak Authentication"
    CSRF = "Anti-CSRF Tokens Check"

    # Information Disclosure
    INFO_DISCLOSURE = "Information Disclosure"
    PATH_TRAVERSAL = "Path Traversal"
    DIRECTORY_LISTING = "Directory Listing"
    SOURCE_CODE_DISCLOSURE = "Source Code Disclosure"

    # Configuration & Deployment
    SECURITY_MISCONFIGURATION = "Security Misconfiguration"
    INSECURE_COMMUNICATION = "Insecure Communication"
    MISSING_SECURITY_HEADERS = "Missing Security Headers"

    # Access Control
    PRIVILEGE_ESCALATION = "Privilege Escalation"
    INSECURE_DIRECT_OBJECT_REF = "Insecure Direct Object Reference"

    # Cryptographic
    WEAK_CRYPTO = "Weak Cryptography"
    INSECURE_RANDOM = "Insecure Randomness"

    # Other
    XXE = "XML External Entity"
    SSRF = "Server Side Request Forgery"
    DESERIALIZATION = "Insecure Deserialization"
    FILE_UPLOAD = "File Upload Vulnerability"


class RiskLevel(Enum):
    """Risk levels for vulnerabilities and chains."""

    INFORMATIONAL = 0
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4

    @classmethod
    def from_string(cls, risk_str: str) -> 'RiskLevel':
        """Convert string risk level to enum."""
        mapping = {
            'Informational': cls.INFORMATIONAL,
            'Low': cls.LOW,
            'Medium': cls.MEDIUM,
            'High': cls.HIGH,
            'Critical': cls.CRITICAL
        }
        return mapping.get(risk_str, cls.INFORMATIONAL)

    def to_numeric(self) -> int:
        """Convert risk level to numeric score."""
        return self.value


class ChainType(Enum):
    """Types of vulnerability chains."""

    AUTHENTICATION_BYPASS = "authentication_bypass"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    DATA_EXFILTRATION = "data_exfiltration"
    REMOTE_CODE_EXECUTION = "remote_code_execution"
    SESSION_HIJACKING = "session_hijacking"
    INFORMATION_GATHERING = "information_gathering"
    COMPOUND_EXPLOIT = "compound_exploit"


# Mapping of vulnerability types to numeric IDs for graph processing
VULNERABILITY_TYPE_IDS: Dict[str, int] = {
    "Cross Site Scripting": 1,
    "SQL Injection": 2,
    "Command Injection": 3,
    "Anti-CSRF Tokens Check": 4,
    "Information Disclosure": 5,
    "Path Traversal": 6,
    "Authentication Bypass": 7,
    "Session Fixation": 8,
    "Privilege Escalation": 9,
    "Weak Authentication": 10,
    "Security Misconfiguration": 11,
    "Missing Security Headers": 12,
    "Weak Cryptography": 13,
    "XML External Entity": 14,
    "Server Side Request Forgery": 15,
    "Insecure Deserialization": 16,
    "File Upload Vulnerability": 17,
    "Directory Listing": 18,
    "Source Code Disclosure": 19,
    "Insecure Direct Object Reference": 20,
    "LDAP Injection": 21,
    "XPath Injection": 22,
    "Insecure Communication": 23,
    "Insecure Randomness": 24
}

# Default scoring weights for chain risk calculation
DEFAULT_CHAIN_WEIGHTS: Dict[str, float] = {
    'base_severity': 1.0,           # Weight for base vulnerability severity
    'chain_length': 0.5,            # Weight for chain length
    'exploitability': 1.5,          # Weight for exploitability factor
    'impact': 2.0,                  # Weight for potential impact
    'confidence': 0.8               # Weight for detection confidence
}

# Minimum confidence threshold for chain detection
MIN_CHAIN_CONFIDENCE: float = 0.6

# Maximum chain length to consider (prevent infinite loops)
# Increased to 4 for better chain detection
MAX_CHAIN_LENGTH: int = 4

# Minimum risk score for a chain to be reported
# Lowered to catch more potential chains
MIN_CHAIN_RISK_SCORE: float = 0.0

# Maximum number of chains to detect (prevent combinatorial explosion)
MAX_CHAINS_TO_DETECT: int = 5000

# Maximum number of paths to explore per source node
# Increased for thorough exploration
MAX_PATHS_PER_SOURCE: int = 500
