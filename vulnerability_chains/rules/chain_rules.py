"""
ChainRuleEngine - Rule-based system for linking vulnerabilities into exploit chains.
"""

import json
import logging
from typing import List, Dict, Any, Optional
from pathlib import Path
from urllib.parse import urlparse

from ..models import Vulnerability, ChainLink
from ..constants import ChainType

logger = logging.getLogger(__name__)


class ChainRule:
    """
    Represents a single rule for linking two vulnerability types.
    """

    def __init__(self, rule_data: Dict[str, Any]):
        """
        Initialize a chain rule from dictionary data.

        Args:
            rule_data: Dictionary containing rule configuration
        """
        self.rule_id = rule_data['rule_id']
        self.name = rule_data['name']
        self.source_type = rule_data['source_type']
        self.target_type = rule_data['target_type']
        self.chain_type = ChainType(rule_data['chain_type'])
        self.conditions = rule_data.get('conditions', {})
        self.exploitability = rule_data.get('exploitability', 0.5)
        self.impact_multiplier = rule_data.get('impact_multiplier', 1.0)
        self.description = rule_data.get('description', '')
        self.exploitation_steps = rule_data.get('exploitation_steps', [])

    def matches(self, source: Vulnerability, target: Vulnerability) -> bool:
        """
        Check if this rule matches a pair of vulnerabilities.
        Uses fuzzy matching to handle variations in vulnerability names.

        Args:
            source: Source vulnerability
            target: Target vulnerability

        Returns:
            True if rule applies to this vulnerability pair
        """
        # Fuzzy matching: Check if rule type is contained in vulnerability name
        # or if vulnerability name contains the rule type
        if not self._fuzzy_match(source.name, self.source_type):
            return False

        if not self._fuzzy_match(target.name, self.target_type):
            return False

        # Check all conditions
        return self._check_conditions(source, target)

    def _fuzzy_match(self, vuln_name: str, rule_type: str) -> bool:
        """
        Fuzzy matching between vulnerability name and rule type.

        Supports:
        - Substring matching: "SQL Injection" matches "SQL Injection - MySQL"
        - Case-insensitive matching
        - Synonym matching: "XSS" matches "Cross Site Scripting"

        Args:
            vuln_name: Actual vulnerability name from ZAP
            rule_type: Expected type from rule

        Returns:
            True if there's a match
        """
        vuln_lower = vuln_name.lower()
        rule_lower = rule_type.lower()

        # Direct substring match
        if rule_lower in vuln_lower:
            return True

        # Reverse: vuln name in rule type (for shorter ZAP names)
        if vuln_lower in rule_lower:
            return True

        # Synonym matching for common vulnerability types
        synonyms = {
            'cross site scripting': ['xss', 'scripting', 'user controllable html'],
            'sql injection': ['sqli', 'sql', 'injection - mysql', 'injection - sqlite',
                            'injection - postgresql', 'injection - oracle'],
            'command injection': ['os command', 'remote command', 'code injection'],
            'directory listing': ['directory browsing', 'directory indexing'],
            'missing security headers': ['x-content-type-options', 'x-frame-options',
                                        'content-security-policy', 'csp header'],
            'anti-csrf tokens check': ['absence of anti-csrf', 'csrf', 'cross-site request forgery'],
            'information disclosure': ['info disclosure', 'information leak', 'data leak',
                                      'timestamp disclosure', 'version disclosure'],
            'session fixation': ['session management', 'session id'],
            'authentication bypass': ['auth bypass', 'authentication'],
            'privilege escalation': ['privilege', 'escalation', 'authorization'],
        }

        # Check if rule_type has synonyms
        for main_type, syn_list in synonyms.items():
            if main_type in rule_lower or rule_lower in main_type:
                # Check if vuln_name matches any synonym
                for synonym in syn_list:
                    if synonym in vuln_lower:
                        return True

        # Check reverse: if vuln_name has synonyms
        for main_type, syn_list in synonyms.items():
            if main_type in vuln_lower or vuln_lower in main_type:
                # Check if rule_type matches any synonym
                for synonym in syn_list:
                    if synonym in rule_lower:
                        return True

        return False

    def _check_conditions(self, source: Vulnerability, target: Vulnerability) -> bool:
        """
        Check if all rule conditions are met.

        Args:
            source: Source vulnerability
            target: Target vulnerability

        Returns:
            True if all conditions are satisfied
        """
        conditions_met = []

        # Check same_domain condition
        if self.conditions.get('same_domain', False):
            source_domain = self._get_domain(source.url)
            target_domain = self._get_domain(target.url)
            if source_domain != target_domain:
                return False
            conditions_met.append('same_domain')

        # Check minimum confidence condition
        min_confidence = self.conditions.get('min_confidence', 0.0)
        if min_confidence > 0:
            # Convert confidence string to numeric value
            source_conf = self._confidence_to_numeric(source.confidence)
            target_conf = self._confidence_to_numeric(target.confidence)
            avg_confidence = (source_conf + target_conf) / 2
            if avg_confidence < min_confidence:
                return False
            conditions_met.append('min_confidence')

        # Check contains_credentials condition
        if self.conditions.get('contains_credentials', False):
            if not self._contains_credentials(source):
                return False
            conditions_met.append('contains_credentials')

        # Check cookie_accessible condition
        if self.conditions.get('cookie_accessible', False):
            if not self._is_cookie_accessible(source):
                return False
            conditions_met.append('cookie_accessible')

        # Check no_rate_limiting condition
        if self.conditions.get('no_rate_limiting', False):
            # This would require additional security header analysis
            # For now, we'll assume it's true if the condition is present
            conditions_met.append('no_rate_limiting')

        # Store which conditions were met for reporting
        self._last_conditions_met = conditions_met

        return True

    def create_link(self, source: Vulnerability, target: Vulnerability) -> ChainLink:
        """
        Create a chain link between two vulnerabilities using this rule.

        Args:
            source: Source vulnerability
            target: Target vulnerability

        Returns:
            ChainLink object
        """
        # Calculate confidence based on vulnerability confidence and rule confidence
        source_conf = self._confidence_to_numeric(source.confidence)
        target_conf = self._confidence_to_numeric(target.confidence)
        link_confidence = (source_conf + target_conf) / 2

        return ChainLink(
            source=source,
            target=target,
            rule_name=self.name,
            confidence=link_confidence,
            exploitability=self.exploitability,
            description=self.description,
            conditions_met=getattr(self, '_last_conditions_met', [])
        )

    @staticmethod
    def _get_domain(url: str) -> str:
        """Extract domain from URL."""
        try:
            parsed = urlparse(url)
            return parsed.netloc
        except Exception:
            return ""

    @staticmethod
    def _confidence_to_numeric(confidence: str) -> float:
        """
        Convert confidence string to numeric value.

        Args:
            confidence: Confidence level string (Low/Medium/High)

        Returns:
            Numeric confidence value (0.0-1.0)
        """
        confidence_map = {
            'Low': 0.3,
            'Medium': 0.6,
            'High': 0.9
        }
        return confidence_map.get(confidence, 0.5)

    @staticmethod
    def _contains_credentials(vuln: Vulnerability) -> bool:
        """
        Check if vulnerability evidence contains credentials.

        Args:
            vuln: Vulnerability to check

        Returns:
            True if credentials are likely present
        """
        credential_keywords = [
            'password', 'passwd', 'pwd', 'secret', 'token', 'key',
            'api_key', 'apikey', 'auth', 'credential', 'session'
        ]

        search_text = ' '.join([
            vuln.evidence or '',
            vuln.attack or '',
            vuln.other_info or '',
            vuln.param or ''
        ]).lower()

        return any(keyword in search_text for keyword in credential_keywords)

    @staticmethod
    def _is_cookie_accessible(vuln: Vulnerability) -> bool:
        """
        Check if cookies are accessible (no HttpOnly flag).

        Args:
            vuln: Vulnerability to check

        Returns:
            True if cookies are potentially accessible
        """
        # Check if vulnerability is XSS-related and might access cookies
        if 'Cross Site Scripting' in vuln.name:
            # Check if HttpOnly is mentioned in evidence/solution
            evidence_text = ' '.join([
                vuln.evidence or '',
                vuln.solution or '',
                vuln.other_info or ''
            ]).lower()

            # If HttpOnly is not mentioned, assume cookies are accessible
            return 'httponly' not in evidence_text

        return False


class ChainRuleEngine:
    """
    Engine for managing and applying vulnerability chain rules.
    """

    def __init__(self, rules_file: Optional[str] = None):
        """
        Initialize the chain rule engine.

        Args:
            rules_file: Path to JSON file containing chain rules
        """
        self.rules: List[ChainRule] = []
        self.rules_by_source: Dict[str, List[ChainRule]] = {}
        self.rules_by_target: Dict[str, List[ChainRule]] = {}

        if rules_file:
            self.load_rules(rules_file)
        else:
            # Load default rules from package
            default_rules_path = Path(__file__).parent.parent / 'config' / 'chain_rules.json'
            self.load_rules(str(default_rules_path))

    def load_rules(self, rules_file: str) -> None:
        """
        Load chain rules from JSON file.

        Args:
            rules_file: Path to JSON file containing rules
        """
        try:
            with open(rules_file, 'r', encoding='utf-8') as f:
                data = json.load(f)

            rules_data = data.get('rules', [])
            self.rules = [ChainRule(rule_data) for rule_data in rules_data]

            # Build indexes for faster lookup
            self._build_indexes()

            logger.info(f"Loaded {len(self.rules)} chain rules from {rules_file}")

        except FileNotFoundError:
            logger.error(f"Rules file not found: {rules_file}")
            raise
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON in rules file: {e}")
            raise
        except Exception as e:
            logger.error(f"Error loading rules: {e}")
            raise

    def _build_indexes(self) -> None:
        """Build indexes for efficient rule lookup."""
        self.rules_by_source.clear()
        self.rules_by_target.clear()

        for rule in self.rules:
            # Index by source type
            if rule.source_type not in self.rules_by_source:
                self.rules_by_source[rule.source_type] = []
            self.rules_by_source[rule.source_type].append(rule)

            # Index by target type
            if rule.target_type not in self.rules_by_target:
                self.rules_by_target[rule.target_type] = []
            self.rules_by_target[rule.target_type].append(rule)

    def find_applicable_rules(self, source: Vulnerability, target: Vulnerability) -> List[ChainRule]:
        """
        Find all rules that apply to a pair of vulnerabilities.

        Args:
            source: Source vulnerability
            target: Target vulnerability

        Returns:
            List of applicable rules
        """
        # Get candidate rules by source type
        candidate_rules = self.rules_by_source.get(source.name, [])

        # Filter rules that match both source and target
        applicable_rules = [
            rule for rule in candidate_rules
            if rule.matches(source, target)
        ]

        return applicable_rules

    def create_links(self, source: Vulnerability, target: Vulnerability) -> List[ChainLink]:
        """
        Create all possible chain links between two vulnerabilities.

        Args:
            source: Source vulnerability
            target: Target vulnerability

        Returns:
            List of chain links created
        """
        applicable_rules = self.find_applicable_rules(source, target)
        links = [rule.create_link(source, target) for rule in applicable_rules]

        if links:
            logger.debug(f"Created {len(links)} links between {source.name} and {target.name}")

        return links

    def get_rules_by_chain_type(self, chain_type: ChainType) -> List[ChainRule]:
        """
        Get all rules for a specific chain type.

        Args:
            chain_type: Type of chain to filter by

        Returns:
            List of matching rules
        """
        return [rule for rule in self.rules if rule.chain_type == chain_type]

    def get_possible_targets(self, source: Vulnerability) -> List[str]:
        """
        Get list of possible target vulnerability types for a source.

        Args:
            source: Source vulnerability

        Returns:
            List of target vulnerability type names
        """
        rules = self.rules_by_source.get(source.name, [])
        return list(set(rule.target_type for rule in rules))

    def get_possible_sources(self, target: Vulnerability) -> List[str]:
        """
        Get list of possible source vulnerability types for a target.

        Args:
            target: Target vulnerability

        Returns:
            List of source vulnerability type names
        """
        rules = self.rules_by_target.get(target.name, [])
        return list(set(rule.source_type for rule in rules))

    def get_statistics(self) -> Dict[str, Any]:
        """
        Get statistics about loaded rules.

        Returns:
            Dictionary containing rule statistics
        """
        chain_types = {}
        for rule in self.rules:
            chain_type_name = rule.chain_type.value
            chain_types[chain_type_name] = chain_types.get(chain_type_name, 0) + 1

        return {
            'total_rules': len(self.rules),
            'unique_source_types': len(self.rules_by_source),
            'unique_target_types': len(self.rules_by_target),
            'rules_by_chain_type': chain_types
        }

    def __len__(self) -> int:
        """Return the number of loaded rules."""
        return len(self.rules)

    def __repr__(self) -> str:
        """String representation of the rule engine."""
        return f"ChainRuleEngine(rules={len(self.rules)})"
