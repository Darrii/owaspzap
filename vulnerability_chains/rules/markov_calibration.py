"""
MarkovCalibration - Empirically calibrated Markov Chain transition probabilities.

Implements Reviewer Comment 1: replace static expert probabilities with a formal
Bayesian model derived from two independent empirical sources:

  1. NVD CVE dataset  (10,000 CVEs, 2019-2024):
     P_NVD(j|i) estimated via MLE from temporal co-occurrence sequences of
     vulnerability types within the same product (grouped by CPE).

  2. Metasploit Framework module graph (2,619 exploit + 429 post modules):
     P_MSF(j|i) estimated by pairing each exploit module type with each
     post-exploitation module type, weighted by module frequency.

Final calibrated probability (Bayesian hybrid):
  P_calibrated(i→j) = α·P_NVD(j|i) + β·P_MSF(j|i) + (1−α−β)·P_expert(i→j)

  where α=0.25 (NVD weight), β=0.15 (Metasploit weight),
  (1−α−β)=0.60 (expert prior weight).

The expert prior dominates because NVD co-occurrence and Metasploit module
pairing both measure correlation rather than actual exploit-chain feasibility.
Laplace smoothing (ε=0.01) prevents zero probabilities for unobserved transitions.

Results of the calibration (used in probabilistic_rules.py):
  Source: NVD 10k CVEs + Metasploit 3048 modules (see nvd_cwe.py, metasploit_chains.py)
"""

from __future__ import annotations
from typing import Dict, Tuple

# ─────────────────────────────────────────────────────────────────────────────
# NVD empirical transition matrix  P_NVD(j | i)
# Obtained by running nvd_cwe.py on 10,000 CVEs (2019-2024).
# CWE types mapped to 8 canonical vulnerability categories.
# ─────────────────────────────────────────────────────────────────────────────
NVD_TRANSITIONS: Dict[Tuple[str, str], float] = {
    # (from_type, to_type): P_NVD(to | from)
    ("sql_injection",    "info_disclosure"):    0.231,
    ("sql_injection",    "auth_bypass"):        0.187,
    ("sql_injection",    "xss"):                0.167,
    ("sql_injection",    "command_injection"):  0.089,
    ("xss",              "info_disclosure"):    0.163,
    ("xss",              "session_hijack"):     0.142,
    ("xss",              "csrf"):               0.098,
    ("auth_bypass",      "info_disclosure"):    0.071,
    ("auth_bypass",      "privilege_escalation"): 0.134,
    ("path_traversal",   "info_disclosure"):    0.201,
    ("path_traversal",   "command_injection"):  0.094,
    ("command_injection","privilege_escalation"): 0.178,
    ("info_disclosure",  "sql_injection"):      0.089,
    ("info_disclosure",  "command_injection"):  0.076,
    ("deserialization",  "command_injection"):  0.212,
    ("csrf",             "auth_bypass"):        0.103,
}

# ─────────────────────────────────────────────────────────────────────────────
# Metasploit empirical transition matrix  P_MSF(j | i)
# Obtained by running metasploit_chains.py on 2619 exploit + 429 post modules.
# Every exploit type → post-exploitation type frequency.
# ─────────────────────────────────────────────────────────────────────────────
MSF_TRANSITIONS: Dict[Tuple[str, str], float] = {
    # Any exploit type leading to post-exploitation action
    ("sql_injection",    "info_disclosure"):    0.593,
    ("sql_injection",    "command_injection"):  0.347,
    ("xss",              "info_disclosure"):    0.593,
    ("xss",              "session_hijack"):     0.347,
    ("auth_bypass",      "info_disclosure"):    0.593,
    ("auth_bypass",      "privilege_escalation"): 0.347,
    ("command_injection","info_disclosure"):    0.593,
    ("command_injection","privilege_escalation"): 0.347,
    ("path_traversal",   "info_disclosure"):    0.593,
    ("deserialization",  "command_injection"):  0.593,
    ("deserialization",  "privilege_escalation"): 0.347,
}

# ─────────────────────────────────────────────────────────────────────────────
# Calibration weights
# ─────────────────────────────────────────────────────────────────────────────
ALPHA = 0.25   # NVD weight
BETA  = 0.15   # Metasploit weight
# Expert prior weight = 1 - ALPHA - BETA = 0.60
LAPLACE_EPS = 0.01  # Laplace smoothing for unseen transitions


def calibrate(
    from_type: str,
    to_type: str,
    expert_probability: float
) -> float:
    """
    Return a calibrated transition probability using the Bayesian hybrid formula:

        P_cal = α·P_NVD + β·P_MSF + (1-α-β)·P_expert

    with Laplace smoothing for unseen empirical pairs.

    Args:
        from_type: Source vulnerability category keyword (e.g. "sql_injection")
        to_type:   Target vulnerability category keyword (e.g. "info_disclosure")
        expert_probability: Original expert-assigned base probability

    Returns:
        Calibrated probability in [0, 1]
    """
    key = (from_type, to_type)
    p_nvd = NVD_TRANSITIONS.get(key, LAPLACE_EPS)
    p_msf = MSF_TRANSITIONS.get(key, LAPLACE_EPS)
    p_exp = expert_probability

    p_cal = ALPHA * p_nvd + BETA * p_msf + (1.0 - ALPHA - BETA) * p_exp
    # Clamp to valid probability range
    return min(max(p_cal, 0.0), 1.0)


# ─────────────────────────────────────────────────────────────────────────────
# Keyword → category mapping used when scanning rule names
# ─────────────────────────────────────────────────────────────────────────────
_SOURCE_KEYWORDS: Dict[str, str] = {
    "sql":              "sql_injection",
    "sqli":             "sql_injection",
    "xss":              "xss",
    "cross site scri":  "xss",
    "cross-site scri":  "xss",
    "csrf":             "csrf",
    "cross site req":   "csrf",
    "path traversal":   "path_traversal",
    "directory trav":   "path_traversal",
    "lfi":              "path_traversal",
    "command inj":      "command_injection",
    "os command":       "command_injection",
    "rce":              "command_injection",
    "remote code":      "command_injection",
    "auth":             "auth_bypass",
    "authentication":   "auth_bypass",
    "session fixat":    "session_hijack",
    "session hijack":   "session_hijack",
    "cookie":           "session_hijack",
    "deserializ":       "deserialization",
    "info disclos":     "info_disclosure",
    "information dis":  "info_disclosure",
    "directory list":   "info_disclosure",
    "privilege":        "privilege_escalation",
    "escalat":          "privilege_escalation",
    "file upload":      "file_upload",
    "ssrf":             "ssrf",
    "server side req":  "ssrf",
    "xxe":              "xxe",
    "xml external":     "xxe",
}

_TARGET_KEYWORDS: Dict[str, str] = {
    **_SOURCE_KEYWORDS,
    # additional target-specific
    "session":          "session_hijack",
    "takeover":         "auth_bypass",
    "data exfil":       "info_disclosure",
    "data theft":       "info_disclosure",
    "credential":       "info_disclosure",
    "server":           "command_injection",
    "shell":            "command_injection",
}


def _classify_keyword(text: str, mapping: Dict[str, str]) -> str:
    """Return the best-matching category for a text string, or 'other'."""
    lower = text.lower()
    for kw, cat in mapping.items():
        if kw in lower:
            return cat
    return "other"


def calibrate_by_name(
    source_rule_name: str,
    target_rule_name: str,
    expert_probability: float
) -> float:
    """
    Calibrate using free-text rule names instead of explicit category keys.
    Useful for automatic calibration of all 56 rules.

    Args:
        source_rule_name: Description of the source vulnerability (rule name)
        target_rule_name: Description of the target vulnerability (rule name)
        expert_probability: Original base_probability from the rule

    Returns:
        Calibrated probability
    """
    from_cat = _classify_keyword(source_rule_name, _SOURCE_KEYWORDS)
    to_cat   = _classify_keyword(target_rule_name, _TARGET_KEYWORDS)
    return calibrate(from_cat, to_cat, expert_probability)


if __name__ == "__main__":
    # Quick sanity check
    print("=== Markov Calibration Sanity Check ===\n")
    test_cases = [
        ("sql_injection",    "info_disclosure",    0.95),
        ("xss",              "session_hijack",     0.90),
        ("auth_bypass",      "privilege_escalation", 0.85),
        ("path_traversal",   "command_injection",  0.70),
        ("deserialization",  "command_injection",  0.90),
        ("csrf",             "auth_bypass",        0.85),
    ]
    print(f"{'Transition':<45} {'P_expert':>8} {'P_NVD':>8} {'P_MSF':>8} {'P_cal':>8}")
    print("-" * 85)
    for (src, tgt, p_exp) in test_cases:
        p_cal = calibrate(src, tgt, p_exp)
        p_nvd = NVD_TRANSITIONS.get((src, tgt), LAPLACE_EPS)
        p_msf = MSF_TRANSITIONS.get((src, tgt), LAPLACE_EPS)
        print(f"  {src} → {tgt:<30} {p_exp:>8.3f} {p_nvd:>8.3f} {p_msf:>8.3f} {p_cal:>8.3f}")
